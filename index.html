<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>App 2√óK: Alimentaci√≥n vs No-alimentaci√≥n (desde 3 estados + temporal)</title>

  <!-- Bootstrap (solo UI) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- jStat -->
  <script src="https://cdn.jsdelivr.net/npm/jstat@1.9.6/dist/jstat.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <!-- SheetJS para leer Excel .xlsx -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    body { background: #0b1220; }
    .card { border: 0; border-radius: 16px; }
    .form-control, .form-select { background: #0b1220; color: #e5e7eb; border-color: #243146; }
    .form-control:focus, .form-select:focus { box-shadow: none; border-color: #3b82f6; }
    .btn-primary { border-radius: 12px; }
    .btn-outline-light, .btn-outline-danger, .btn-outline-warning { border-radius: 12px; }
    .small-muted { color: #94a3b8; }
    .pill { display:inline-block; padding:.15rem .5rem; border-radius:999px; font-size:.8rem; }
    .pill-ok { background:#064e3b; color:#a7f3d0; }
    .pill-warn { background:#7c2d12; color:#fed7aa; }
    .pill-bad { background:#7f1d1d; color:#fecaca; }

    /* Cards siguen oscuras, tablas en blanco */
    .card { background: #0f172a; color: #e5e7eb; }
    .table { background: #ffffff; color: #000000; }

    /* Encabezados tablas */
    .table thead th{
      background: #001A72;
      color: #ffffff;
      border-color: #001A72 !important;
    }

    /* Celdas */
    .table tbody td, .table tbody th{
      color: #000000;
      background: #ffffff;
      border-color: #d0d7de;
    }

    /* Rayado suave */
    .table tbody tr:nth-child(even) td,
    .table tbody tr:nth-child(even) th{
      background: #f6f8fa;
    }

    .table thead tr { background: #001A72; }
    .table { border-collapse: separate; border-spacing: 0; }
    .table th, .table td{
      border-right: 2px solid #9aa4b2 !important;
      border-bottom: 1px solid #c7ced8 !important;
    }
    .table tr > *:first-child{ border-left: 2px solid #9aa4b2 !important; }
    .table thead tr > *{ border-top: 2px solid #001A72 !important; }
    .table tbody tr:hover td, .table tbody tr:hover th{ background: #eef2ff; }

    code { color:#93c5fd; }

    /* Tabs */
    .nav-tabs { border-bottom: 0; }
    .nav-tabs .nav-link { color:#e5e7eb; border:0; border-bottom:2px solid transparent; background: transparent; }
    .nav-tabs .nav-link.active { color:#ffffff; border-bottom:2px solid #3b82f6; background: transparent; }

    /* Charts */
    .chart-wrap{
      position: relative;
      width: 100%;
      height: 320px;
      min-height: 260px;
      background: #ffffff;
      border-radius: 12px;
      padding: 10px;
      overflow: hidden;
    }
    canvas{
      width: 100% !important;
      height: 100% !important;
      display: block;
      background: #ffffff;
      border-radius: 10px;
    }

    .mini-note{
      font-size: .85rem;
      color: #cbd5e1;
    }

    .ghost-card{
      border: 1px dashed #334155;
      border-radius: 14px;
      padding: 14px;
      background: rgba(15,23,42,.5);
    }
  </style>
</head>

<body>
<div class="container py-4">
  <div class="row g-3">

    <!-- Header -->
    <div class="col-12">
      <div class="card p-4">
        <div class="d-flex flex-wrap gap-2 align-items-center justify-content-between">
          <div>
            <h1 class="h4 mb-1">App 2√óK: Alimentaci√≥n vs No-alimentaci√≥n (desde 3 estados + temporal)</h1>
            <div class="small-muted">
              Ahora soporta <b>serie temporal</b> (estado + tratamiento + tiempo). Si cargas/ingresas temporal, la app:
              <b>recalcula 3√óK</b>, colapsa a 2√óK y genera gr√°ficos temporales coherentes.
            </div>
          </div>
          <div class="d-flex gap-2">
            <button class="btn btn-outline-light" id="btnExample">Cargar ejemplo</button>
            <button class="btn btn-outline-light" id="btnClear">Limpiar</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Tabs -->
    <div class="col-12">
      <ul class="nav nav-tabs" id="mainTabs" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link active" id="tab-analisis" data-bs-toggle="tab"
                  data-bs-target="#pane-analisis" type="button" role="tab" aria-controls="pane-analisis" aria-selected="true">
            An√°lisis
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="tab-manual" data-bs-toggle="tab"
                  data-bs-target="#pane-manual" type="button" role="tab" aria-controls="pane-manual" aria-selected="false">
            üìò Manual
          </button>
        </li>
      </ul>
    </div>

    <!-- Tab content wrapper -->
    <div class="col-12">
      <div class="tab-content" id="mainTabsContent">

        <!-- ===================== -->
        <!-- PANE: AN√ÅLISIS -->
        <!-- ===================== -->
        <div class="tab-pane fade show active" id="pane-analisis" role="tabpanel" aria-labelledby="tab-analisis">
          <div class="row g-3">

            <!-- Entrada -->
            <div class="col-12">
              <div class="card p-4">

                <div class="d-flex flex-wrap gap-2 align-items-center justify-content-between mb-2">
                  <h2 class="h6 mb-0">1A) Tabla observada (3 estados)</h2>
                  <div class="d-flex gap-2">
                    <button class="btn btn-outline-light" id="btnAddCol">+ Tratamiento</button>
                    <button class="btn btn-outline-danger" id="btnRemoveCol">- √öltimo</button>
                  </div>
                </div>

                <div class="row g-2 mt-2">
                  <div class="col-md-6">
                    <label class="form-label">Subir Excel/CSV (3√óK)</label>
                    <input class="form-control" type="file" id="fileExcel" accept=".xlsx,.xls,.csv" />
                    <div class="small-muted">
                      Debe tener columna <b>estado</b> y luego una columna por tratamiento.
                      Filas: <b>alimentaci√≥n</b>, <b>excitaci√≥n</b>, <b>inmovil</b>.
                    </div>
                  </div>
                  <div class="col-md-6">
                    <div class="ghost-card h-100">
                      <div class="mini-note">
                        <b>Regla:</b> si existe data temporal (1B), la app usa esa como fuente √∫nica y
                        <b>reconstruye</b> autom√°ticamente esta tabla 3√óK. Si no hay temporal, se usa lo que ingreses aqu√≠.
                      </div>
                      <div class="d-flex gap-2 mt-2">
                        <button class="btn btn-outline-warning btn-sm" id="btnSyncTemporalNames">Sincronizar tratamientos (1B) desde 3√óK</button>
                        <button class="btn btn-outline-light btn-sm" id="btnClearTemporal">Limpiar temporal</button>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="table-responsive mt-3">
                  <table class="table table-sm align-middle" id="obsTable">
                    <thead>
                      <tr id="headRow">
                        <th style="min-width:200px">Estado</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr id="rowFeed">
                        <th>Alimentaci√≥n</th>
                      </tr>
                      <tr id="rowExcit">
                        <th>Excitaci√≥n</th>
                      </tr>
                      <tr id="rowImmob">
                        <th>Inm√≥vil</th>
                      </tr>
                    </tbody>
                  </table>
                </div>

                <!-- ===== 1B Temporal ===== -->
                <hr class="border-secondary my-4"/>

                <div class="d-flex flex-wrap gap-2 align-items-center justify-content-between mb-2">
                  <h2 class="h6 mb-0">1B) Serie temporal (formato largo)</h2>
                  <div class="d-flex gap-2">
                    <button class="btn btn-outline-light" id="btnAddTempRow">+ Fila</button>
                    <button class="btn btn-outline-danger" id="btnRemoveTempRow">- √öltima</button>
                  </div>
                </div>

                <div class="row g-2">
                  <div class="col-md-6">
                    <label class="form-label">Subir Excel/CSV (temporal)</label>
                    <input class="form-control" type="file" id="fileTemporal" accept=".xlsx,.xls,.csv" />
                    <div class="small-muted">
                      Columnas requeridas: <b>tratamiento</b>, <b>estado</b>, <b>tiempo</b>, <b>valor</b>.
                      Estado debe ser: alimentaci√≥n / excitaci√≥n / inmovil (se normaliza).
                    </div>
                  </div>
                  <div class="col-md-6">
                    <label class="form-label">Tip</label>
                    <div class="ghost-card">
                      <div class="mini-note">
                        - Puedes repetir tiempos (0,5,10,15...) por tratamiento y estado.<br>
                        - Si el mismo (tratamiento, estado, tiempo) aparece m√°s de una vez, se <b>suma</b>.<br>
                        - Al calcular, se agregan los totales temporales y se reconstruye 3√óK.
                      </div>
                    </div>
                  </div>
                </div>

                <div class="table-responsive mt-3">
                  <table class="table table-sm align-middle" id="tempTable">
                    <thead>
                      <tr>
                        <th style="min-width:260px">Tratamiento</th>
                        <th style="min-width:180px">Estado</th>
                        <th style="min-width:120px">Tiempo</th>
                        <th style="min-width:120px">Valor</th>
                      </tr>
                    </thead>
                    <tbody id="tempBody"></tbody>
                  </table>
                </div>

                <div class="row g-3 mt-1">
                  <div class="col-md-3">
                    <label class="form-label">Simulaciones Fisher MC</label>
                    <input class="form-control" id="nSim" type="number" min="1000" step="1000" value="100000" />
                    <div class="small-muted">M√°s simulaciones = p m√°s estable (pero m√°s lento).</div>
                  </div>
                  <div class="col-md-3">
                    <label class="form-label">Semilla</label>
                    <input class="form-control" id="seed" type="number" step="1" value="123" />
                  </div>
                  <div class="col-md-3">
                    <label class="form-label">Nivel de significancia (Œ±)</label>
                    <input class="form-control" id="alpha" type="number" min="0.001" max="0.50" step="0.01" value="0.05" />
                  </div>
                  <div class="col-md-3 d-flex align-items-end">
                    <button class="btn btn-primary w-100" id="btnRun">Calcular</button>
                  </div>
                </div>

                <div class="small-muted mt-3">
                  Nota: an√°lisis global sobre 2√óK colapsando <b>No_alimentaci√≥n = Excitaci√≥n + Inm√≥vil</b>.
                  Si hay temporal, se usa como fuente √∫nica y esta tabla 3√óK se recalcula autom√°ticamente.
                </div>

              </div>
            </div>

            <!-- Resultados -->
            <div class="col-12 col-lg-6">
              <div class="card p-4 h-100">
                <h2 class="h6">2) Resultados globales (2√óK)</h2>
                <div id="globalOut" class="mt-2"></div>
                <hr class="border-secondary" />
                <h2 class="h6">3) Esperados (E)</h2>
                <div class="table-responsive" id="expectedWrap"></div>
              </div>
            </div>

            <div class="col-12 col-lg-6">
              <div class="card p-4 h-100">
                <h2 class="h6">4) Proporci√≥n de Alimentaci√≥n y gr√°fico</h2>
                <div id="propOut" class="mt-2"></div>

                <div class="mt-3 chart-wrap">
                  <canvas id="barChart"></canvas>
                </div>

                <div class="mt-4 chart-wrap">
                  <canvas id="behavChart"></canvas>
                </div>

                <div class="mt-4">
                  <div class="small-muted mb-2">√Åreas acumuladas por tratamiento (tiempo en eje X) ‚Äî desde temporal</div>
                  <div id="areaChartsWrap" class="d-grid gap-3"></div>
                </div>

                <div class="d-flex gap-2 mt-3">
                  <button class="btn btn-outline-light" id="btnDownloadCSV">Descargar resumen CSV</button>
                </div>
              </div>
            </div>

            <div class="col-12">
              <div class="card p-4">
                <h2 class="h6">5) Residuos z y p-values por celda (2√óK)</h2>
                <div class="table-responsive" id="residWrap"></div>
                <div class="small-muted mt-2">Regla orientativa: |z| &gt; 1.96 ‚âà p &lt; 0.05 (sin correcci√≥n).</div>
              </div>
            </div>

            <div class="col-12">
              <div class="card p-4">
                <h2 class="h6">6) Comparaciones por pares (Fisher 2√ó2) + ajuste Holm</h2>
                <div class="small-muted mb-2">
                  Compara cada par de tratamientos A vs B. p_fisher (sin ajustar) y p_holm (ajustado).
                </div>
                <div class="table-responsive" id="pairsWrap"></div>
              </div>
            </div>

            <div class="col-12">
              <div class="card p-4">
                <h2 class="h6">7) Matriz de p-values (Fisher 2√ó2, sin ajustar)</h2>
                <div class="small-muted mb-2">
                  * indica p &lt; Œ± (seg√∫n el Œ± ingresado arriba).
                </div>
                <div class="table-responsive" id="pMatWrap"></div>
              </div>
            </div>

            <div class="col-12">
              <div class="card p-4">
                <h2 class="h6">8) Potencia estimada por comparaci√≥n (aprox.)</h2>
                <div class="small-muted mb-2">
                  Estimaci√≥n aproximada (normal) usando diferencia de proporciones y n observados.
                </div>
                <div class="table-responsive" id="powerWrap"></div>
              </div>
            </div>

          </div>
        </div>

        <!-- ===================== -->
        <!-- PANE: MANUAL -->
        <!-- ===================== -->
        <div class="tab-pane fade" id="pane-manual" role="tabpanel" aria-labelledby="tab-manual">
          <div class="card p-4 mt-3">
            <h2 class="h6 mb-2">üìò Manual de interpretaci√≥n</h2>
            <div class="small-muted mb-3">Gu√≠a r√°pida para leer los resultados de la app.</div>

            <h3 class="h6 mt-3">Entrada (3 estados + temporal)</h3>
            <div>
              Puedes ingresar 3√óK (Alimentaci√≥n/Excitaci√≥n/Inm√≥vil) o ingresar temporal (tratamiento/estado/tiempo/valor).
              Si hay temporal, se usa como fuente √∫nica y se reconstruye 3√óK autom√°ticamente.
              Para el an√°lisis global:
              <code>No_alimentaci√≥n = Excitaci√≥n + Inm√≥vil</code>.
            </div>

            <h3 class="h6 mt-3">Chi-cuadrado (œá¬≤)</h3>
            <div>
              Mide discrepancia global entre observado (O) y esperado (E) bajo H0.
            </div>

            <h3 class="h6 mt-3">V de Cram√©r</h3>
            <div>
              Magnitud del efecto: ‚âà0.1 peque√±o, ‚âà0.3 mediano, ‚â•0.5 grande.
            </div>

            <h3 class="h6 mt-3">Temporal</h3>
            <div>
              La tabla temporal (formato largo) es la base correcta para que todo ‚Äúcalce‚Äù:
              el 3√óK, 2√óK y gr√°ficos.
            </div>
          </div>
        </div>

      </div>
    </div>

  </div>
</div>

<script>
  // =========================
  // Utilidades
  // =========================
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const fmt = (x, d=4) => (Number.isFinite(x) ? x.toFixed(d) : 'NA');
  const fmtP = (p) => (Number.isFinite(p) ? (p < 0.0001 ? '<0.0001' : p.toFixed(4)) : 'NA');
  const sum = (arr) => arr.reduce((a,b)=>a+b,0);

  function pill(text, kind){
    const cls = kind === 'ok' ? 'pill-ok' : kind === 'warn' ? 'pill-warn' : 'pill-bad';
    return `<span class="pill ${cls}">${text}</span>`;
  }

  function safeInt(v){
    const n = Number(v);
    if (!Number.isFinite(n) || n < 0) return 0;
    return Math.floor(n);
  }

  function safeNum(v){
    const n = Number(v);
    if (!Number.isFinite(n)) return NaN;
    return n;
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  function normalizeEstado(s){
    s = String(s || '').toLowerCase().trim();
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    if (s.includes('aliment')) return 'alimentacion';
    if (s.includes('excit')) return 'excitacion';
    if (s.includes('inmov')) return 'inmovil';
    return s;
  }

  function estadoLabel(norm){
    if (norm === 'alimentacion') return 'Alimentaci√≥n';
    if (norm === 'excitacion') return 'Excitaci√≥n';
    if (norm === 'inmovil') return 'Inm√≥vil';
    return norm;
  }

  // =========================
  // RNG + Hypergeom (Fisher MC)
  // =========================
  function makeRng(seed){
    let x = (seed >>> 0) || 123456789;
    return function(){
      x ^= x << 13; x >>>= 0;
      x ^= x >> 17; x >>>= 0;
      x ^= x << 5;  x >>>= 0;
      return (x >>> 0) / 4294967296;
    }
  }

  function logFactorial(n){
    if (n < 2) return 0;
    return n*Math.log(n) - n + 0.5*Math.log(2*Math.PI*n) + 1/(12*n) - 1/(360*n*n*n);
  }

  function logChoose(n,k){
    if (k < 0 || k > n) return -Infinity;
    return logFactorial(n) - logFactorial(k) - logFactorial(n-k);
  }

  function hypergeomPmf(x, K, N, n){
    if (x < 0 || x > K || x > n || n-x > (N-K)) return 0;
    const logp = logChoose(K,x) + logChoose(N-K, n-x) - logChoose(N,n);
    return Math.exp(logp);
  }

  function hypergeomSample(rng, K, N, n){
    const xmin = Math.max(0, n - (N - K));
    const xmax = Math.min(n, K);
    let u = rng();
    let c = 0;
    for (let x = xmin; x <= xmax; x++){
      c += hypergeomPmf(x, K, N, n);
      if (u <= c) return x;
    }
    return xmax;
  }

  // =========================
  // C√°lculos 2√óK
  // =========================
  function chiSquare2xK(obs2xK){
    const K = obs2xK[0].length;
    const rowTotals = [sum(obs2xK[0]), sum(obs2xK[1])];
    const colTotals = Array.from({length: K}, (_,j)=> obs2xK[0][j] + obs2xK[1][j]);
    const N = rowTotals[0] + rowTotals[1];

    const E = [[],[]];
    for (let j=0;j<K;j++){
      E[0][j] = rowTotals[0] * colTotals[j] / N;
      E[1][j] = rowTotals[1] * colTotals[j] / N;
    }

    let chi2 = 0;
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++){
        const e = E[i][j];
        if (e > 0) chi2 += (obs2xK[i][j]-e)*(obs2xK[i][j]-e)/e;
      }
    }

    const dof = (2-1)*(K-1);
    const p = 1 - jStat.chisquare.cdf(chi2, dof);

    const denom = Math.min(2-1, K-1);
    const V = denom > 0 ? Math.sqrt(chi2 / (N * denom)) : NaN;

    return {chi2, p, dof, E, N, V};
  }

  function stdResiduals(obs, E){
    const K = obs[0].length;
    const Z = [[],[]];
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++){
        Z[i][j] = (obs[i][j] - E[i][j]) / Math.sqrt(E[i][j]);
      }
    }
    return Z;
  }

  function pvalsFromZ(Z){
    const K = Z[0].length;
    const P = [[],[]];
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++){
        const z = Math.abs(Z[i][j]);
        P[i][j] = 2*(1 - jStat.normal.cdf(z, 0, 1));
      }
    }
    return P;
  }

  function bonferroni(P){
    const K = P[0].length;
    const m = 2*K;
    const out = [[],[]];
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++) out[i][j] = clamp01(P[i][j]*m);
    }
    return out;
  }

  function holm(P){
    const K = P[0].length;
    const m = 2*K;
    const flat = [];
    for (let i=0;i<2;i++) for (let j=0;j<K;j++) flat.push({i,j,p:P[i][j]});
    flat.sort((a,b)=>a.p-b.p);

    let runningMax = 0;
    for (let k=0;k<m;k++){
      const t = k+1;
      const adj = (m - t + 1) * flat[k].p;
      runningMax = Math.max(runningMax, adj);
      flat[k].adj = clamp01(runningMax);
    }

    const out = [Array(K).fill(0), Array(K).fill(0)];
    for (const el of flat){ out[el.i][el.j] = el.adj; }
    return out;
  }

  function fisherMC2xK(obs2xK, nSim=100000, seed=123){
    const K = obs2xK[0].length;
    const colTotals = Array.from({length: K}, (_,j)=> obs2xK[0][j] + obs2xK[1][j]);
    const row1Tot = sum(obs2xK[0]);

    const {chi2: chiObs} = chiSquare2xK(obs2xK);

    const rng = makeRng(seed);
    let countGE = 0;

    for (let s=0; s<nSim; s++){
      let remainingSuccess = row1Tot;
      const remainingCol = colTotals.slice();
      const alloc = new Array(K).fill(0);

      for (let j=0; j<K-1; j++){
        const N = sum(remainingCol);
        const Kgood = remainingCol[j];
        const n = remainingSuccess;
        const x = hypergeomSample(rng, Kgood, N, n);
        alloc[j] = x;
        remainingSuccess -= x;
        remainingCol[j] = 0;
      }
      alloc[K-1] = remainingSuccess;

      const sim = [alloc, colTotals.map((ct,j)=>ct-alloc[j])];
      const {chi2: chiSim} = chiSquare2xK(sim);
      if (chiSim >= chiObs) countGE++;
    }

    return {chiObs, p: countGE / nSim};
  }

  // Fisher exacto 2√ó2
  function fisherExactTwoSided(a,b,c,d){
    const r1 = a + b, r2 = c + d;
    const c1 = a + c, c2 = b + d;
    const n  = r1 + r2;

    const OR = ((a+0.5)*(d+0.5))/((b+0.5)*(c+0.5));

    const amin = Math.max(0, r1 - c2);
    const amax = Math.min(r1, c1);

    function logHyp(a0){
      return logChoose(c1, a0) + logChoose(c2, r1-a0) - logChoose(n, r1);
    }

    const pObs = Math.exp(logHyp(a));
    let pTwo = 0;
    for (let x=amin; x<=amax; x++){
      const px = Math.exp(logHyp(x));
      if (px <= pObs + 1e-12) pTwo += px;
    }
    return {OR, p: clamp01(pTwo)};
  }

  function holm1D(pvals){
    const m = pvals.length;
    const order = [...pvals.keys()].sort((i,j)=>pvals[i]-pvals[j]);
    let runningMax = 0;
    const adj = new Array(m).fill(1);
    for (let k=0;k<m;k++){
      const i = order[k];
      const factor = (m - k);
      runningMax = Math.max(runningMax, pvals[i]*factor);
      adj[i] = clamp01(runningMax);
    }
    return adj;
  }

  function pairwiseComparisons(names, obs, alpha){
    const K = names.length;
    const feed = obs[0], nofeed = obs[1];
    const totals = names.map((_,j)=> feed[j] + nofeed[j]);
    const props = names.map((_,j)=> feed[j] / totals[j]);

    const rows = [];
    const pList = [];

    for (let i=0;i<K;i++){
      for (let j=i+1;j<K;j++){
        const a = feed[i], b = nofeed[i], c = feed[j], d = nofeed[j];
        const fe = fisherExactTwoSided(a,b,c,d);
        pList.push(fe.p);

        rows.push({
          A: names[i], B: names[j],
          n_A: totals[i], n_B: totals[j],
          A_feed: a, A_no: b, B_feed: c, B_no: d,
          prop_A: props[i], prop_B: props[j],
          diff_prop: (props[i] - props[j]),
          odds_ratio: fe.OR,
          p_fisher: fe.p
        });
      }
    }

    const pHolm = holm1D(pList);
    rows.forEach((r, idx) => r.p_holm = pHolm[idx]);
    rows.forEach(r=>{
      r.significativo = (r.p_holm < alpha) ? "S√≠" : "No";
      r.tendencia = (r.p_fisher < 0.10) ? "S√≠" : "No";
    });

    rows.sort((x,y)=> x.p_fisher - y.p_fisher);

    const pMat = Array.from({length:K}, ()=> Array(K).fill(1));
    rows.forEach(r=>{
      const i = names.indexOf(r.A);
      const j = names.indexOf(r.B);
      pMat[i][j] = r.p_fisher;
      pMat[j][i] = r.p_fisher;
    });

    // Potencia (aprox normal)
    const powerRows = [];
    for (let i=0;i<K;i++){
      for (let j=i+1;j<K;j++){
        const p1 = props[i], p2 = props[j];
        const n1 = totals[i], n2 = totals[j];

        const se = Math.sqrt((p1*(1-p1))/n1 + (p2*(1-p2))/n2);
        const zAlpha = jStat.normal.inv(1 - alpha/2, 0, 1);

        const delta = Math.abs(p1 - p2);
        const zEff = (se > 0) ? (delta / se) : 0;

        const power = 1 - jStat.normal.cdf(zAlpha - zEff, 0, 1) + jStat.normal.cdf(-zAlpha - zEff, 0, 1);

        powerRows.push({
          A: names[i], B: names[j],
          prop_A: p1, prop_B: p2,
          diff_pp: (p1 - p2) * 100,
          power: clamp01(power)
        });
      }
    }
    powerRows.sort((x,y)=> y.power - y.power);

    return {rows, pMat, powerRows};
  }

  function renderPairsTable(rows, alpha){
    if (!rows.length) return '<div class="small-muted">No hay pares para comparar.</div>';

    const header = `
      <thead><tr>
        <th>A</th><th>B</th>
        <th>prop_A</th><th>prop_B</th><th>Œî pp</th>
        <th>Odds Ratio</th>
        <th>p_fisher</th><th>p_holm</th>
        <th>Significativo (Œ±=${alpha})</th>
        <th>Tendencia p&lt;0.10</th>
      </tr></thead>`;

    const body = rows.map(r=>{
      const propA = `${(r.prop_A*100).toFixed(1)}% (${r.A_feed}/${r.n_A})`;
      const propB = `${(r.prop_B*100).toFixed(1)}% (${r.B_feed}/${r.n_B})`;
      const dpp = (r.diff_prop*100).toFixed(2);

      return `<tr>
        <td>${escapeHtml(r.A)}</td>
        <td>${escapeHtml(r.B)}</td>
        <td>${propA}</td>
        <td>${propB}</td>
        <td>${dpp}</td>
        <td>${fmt(r.odds_ratio,3)}</td>
        <td>${fmtP(r.p_fisher)}</td>
        <td>${fmtP(r.p_holm)}</td>
        <td><b>${r.significativo}</b></td>
        <td>${r.tendencia}</td>
      </tr>`;
    }).join('');

    return `<table class="table table-sm align-middle">${header}<tbody>${body}</tbody></table>`;
  }

  function renderPMatrix(names, pMat, alpha){
    const K = names.length;
    let html = '<table class="table table-sm align-middle">';
    html += '<thead><tr><th></th>' + names.map(n=>`<th>${escapeHtml(n)}</th>`).join('') + '</tr></thead>';
    html += '<tbody>';
    for (let i=0;i<K;i++){
      html += `<tr><th>${escapeHtml(names[i])}</th>`;
      for (let j=0;j<K;j++){
        const p = pMat[i][j];
        const star = (i!==j && p < alpha) ? ' <b>*</b>' : '';
        html += `<td>${fmt(p,4)}${star}</td>`;
      }
      html += '</tr>';
    }
    html += '</tbody></table>';
    return html;
  }

  function renderPowerTable(rows){
    if (!rows.length) return '<div class="small-muted">No hay potencia para calcular.</div>';

    const header = `
      <thead><tr>
        <th>A</th><th>B</th>
        <th>prop_A</th><th>prop_B</th>
        <th>Œî pp</th>
        <th>Potencia (aprox.)</th>
      </tr></thead>`;

    const body = rows.map(r=>{
      return `<tr>
        <td>${escapeHtml(r.A)}</td>
        <td>${escapeHtml(r.B)}</td>
        <td>${(r.prop_A*100).toFixed(1)}%</td>
        <td>${(r.prop_B*100).toFixed(1)}%</td>
        <td>${r.diff_pp.toFixed(1)}</td>
        <td><b>${r.power.toFixed(2)}</b></td>
      </tr>`;
    }).join('');

    return `<table class="table table-sm align-middle">${header}<tbody>${body}</tbody></table>`;
  }

  // =========================
  // UI 3√óK
  // =========================
  const headRow  = document.getElementById('headRow');
  const rowFeed  = document.getElementById('rowFeed');
  const rowExcit = document.getElementById('rowExcit');
  const rowImmob = document.getElementById('rowImmob');

  const btnAddCol    = document.getElementById('btnAddCol');
  const btnRemoveCol = document.getElementById('btnRemoveCol');

  let chart = null;       // barChart
  let behavChart = null;  // behavChart (100% apilado por tratamiento)
  let areaCharts = [];    // √°reas acumuladas por tratamiento
  let lastSummaryRows = null;

  // ===== Temporal state =====
  const tempBody = document.getElementById('tempBody');
  let temporalRows = []; // [{tratamiento, estado(norm), tiempo(num), valor(int)}]

  function colCount(){
    return headRow.querySelectorAll('th.colhdr').length;
  }

  function addColumn(name="Tratamiento"){
    const k = colCount() + 1;

    const th = document.createElement('th');
    th.className = 'colhdr';
    th.style.minWidth = '240px';
    th.innerHTML = `
      <div class="d-flex flex-column gap-1">
        <input class="form-control form-control-sm" data-role="colname" value="${escapeHtml(name)} ${k}" />
        <div class="small-muted">(conteos enteros ‚â• 0)</div>
      </div>
    `;
    headRow.appendChild(th);

    const tdFeed = document.createElement('td');
    tdFeed.innerHTML = `<input class="form-control form-control-sm" data-role="feed" type="number" min="0" step="1" value="0" />`;
    rowFeed.appendChild(tdFeed);

    const tdExc = document.createElement('td');
    tdExc.innerHTML = `<input class="form-control form-control-sm" data-role="excit" type="number" min="0" step="1" value="0" />`;
    rowExcit.appendChild(tdExc);

    const tdImm = document.createElement('td');
    tdImm.innerHTML = `<input class="form-control form-control-sm" data-role="immob" type="number" min="0" step="1" value="0" />`;
    rowImmob.appendChild(tdImm);
  }

  function removeLastColumn(){
    const k = colCount();
    if (k <= 2) return;
    headRow.removeChild(headRow.lastElementChild);
    rowFeed.removeChild(rowFeed.lastElementChild);
    rowExcit.removeChild(rowExcit.lastElementChild);
    rowImmob.removeChild(rowImmob.lastElementChild);
  }

  function clearOutputs(){
    document.getElementById('globalOut').innerHTML = '';
    document.getElementById('expectedWrap').innerHTML = '';
    document.getElementById('residWrap').innerHTML = '';
    document.getElementById('propOut').innerHTML = '';
    document.getElementById('pairsWrap').innerHTML = '';
    document.getElementById('pMatWrap').innerHTML = '';
    document.getElementById('powerWrap').innerHTML = '';
    lastSummaryRows = null;

    if (chart){ chart.destroy(); chart = null; }
    if (behavChart){ behavChart.destroy(); behavChart = null; }
    destroyAreaCharts();
  }

  function clearAll(){
    while (colCount() > 4) removeLastColumn();
    while (colCount() < 4) addColumn('Tratamiento');

    [...headRow.querySelectorAll('input[data-role="colname"]')].forEach((el, idx)=> el.value = `Tratamiento ${idx+1}`);
    [...document.querySelectorAll('input[data-role="feed"], input[data-role="excit"], input[data-role="immob"]')]
      .forEach(el => el.value = 0);

    temporalRows = [];
    renderTemporalTable();

    clearOutputs();
  }

  // =========================
  // Temporal UI
  // =========================
  function addTemporalRow(obj = null){
    const baseNames = getTreatmentNamesFrom3xK();
    const t0 = baseNames[0] ?? "Tratamiento 1";
    const row = obj ?? { tratamiento: t0, estado: 'alimentacion', tiempo: 0, valor: 0 };
    temporalRows.push(row);
    renderTemporalTable();
  }

  function removeTemporalRow(){
    if (!temporalRows.length) return;
    temporalRows.pop();
    renderTemporalTable();
  }

  function renderTemporalTable(){
    tempBody.innerHTML = '';
    const baseNames = getTreatmentNamesFrom3xK();

    temporalRows.forEach((r, idx) => {
      const tr = document.createElement('tr');

      const tdT = document.createElement('td');
      tdT.innerHTML = `
        <input class="form-control form-control-sm" data-temp="trat" data-idx="${idx}"
               value="${escapeHtml(r.tratamiento ?? '')}" list="treatList" />
      `;
      tr.appendChild(tdT);

      const tdS = document.createElement('td');
      tdS.innerHTML = `
        <select class="form-select form-select-sm" data-temp="estado" data-idx="${idx}">
          <option value="alimentacion">Alimentaci√≥n</option>
          <option value="excitacion">Excitaci√≥n</option>
          <option value="inmovil">Inm√≥vil</option>
        </select>
      `;
      tr.appendChild(tdS);

      const tdTime = document.createElement('td');
      tdTime.innerHTML = `
        <input class="form-control form-control-sm" data-temp="tiempo" data-idx="${idx}"
               type="number" step="1" value="${Number.isFinite(r.tiempo) ? r.tiempo : 0}" />
      `;
      tr.appendChild(tdTime);

      const tdV = document.createElement('td');
      tdV.innerHTML = `
        <input class="form-control form-control-sm" data-temp="valor" data-idx="${idx}"
               type="number" min="0" step="1" value="${safeInt(r.valor)}" />
      `;
      tr.appendChild(tdV);

      tempBody.appendChild(tr);

      // set estado
      const sel = tr.querySelector('select[data-temp="estado"]');
      sel.value = r.estado ?? 'alimentacion';
    });

    // datalist treatments (para autocompletar)
    let dl = document.getElementById('treatList');
    if (!dl){
      dl = document.createElement('datalist');
      dl.id = 'treatList';
      document.body.appendChild(dl);
    }
    dl.innerHTML = baseNames.map(n => `<option value="${escapeHtml(n)}"></option>`).join('');
  }

  // Update temporalRows on input
  tempBody.addEventListener('input', (e) => {
    const idx = safeInt(e.target.getAttribute('data-idx'));
    const field = e.target.getAttribute('data-temp');
    if (!Number.isFinite(idx) || !field || !temporalRows[idx]) return;

    if (field === 'trat'){
      temporalRows[idx].tratamiento = String(e.target.value || '').trim();
    } else if (field === 'estado'){
      temporalRows[idx].estado = normalizeEstado(e.target.value);
    } else if (field === 'tiempo'){
      temporalRows[idx].tiempo = safeNum(e.target.value);
    } else if (field === 'valor'){
      temporalRows[idx].valor = safeInt(e.target.value);
    }
  });

  // =========================
  // Helpers: leer 3√óK (manual) y temporal
  // =========================
  function getTreatmentNamesFrom3xK(){
    return [...headRow.querySelectorAll('input[data-role="colname"]')]
      .map(x => (x.value || '').trim())
      .map(x => x || 'Sin nombre');
  }

  function read3xKTableManual(){
    const names = getTreatmentNamesFrom3xK();
    const feed  = [...rowFeed.querySelectorAll('input[data-role="feed"]')].map(x => safeInt(x.value));
    const excit = [...rowExcit.querySelectorAll('input[data-role="excit"]')].map(x => safeInt(x.value));
    const immob = [...rowImmob.querySelectorAll('input[data-role="immob"]')].map(x => safeInt(x.value));

    if (names.length < 2) throw new Error('Necesitas al menos 2 tratamientos.');

    const nofeed = excit.map((v,i)=> v + immob[i]);
    const obs = [feed, nofeed];
    const N = sum(feed) + sum(nofeed);
    if (N === 0) throw new Error('La tabla est√° vac√≠a (N=0).');

    const colTotals = names.map((_,j)=> feed[j] + nofeed[j]);
    if (colTotals.some(t => t === 0)){
      throw new Error('Hay tratamientos con total 0. Llena al menos una celda por tratamiento.');
    }

    return { names, obs, raw3: {feed, excit, immob} };
  }

  function hasTemporalData(){
    return temporalRows.some(r =>
      String(r.tratamiento || '').trim().length &&
      ['alimentacion','excitacion','inmovil'].includes(normalizeEstado(r.estado)) &&
      Number.isFinite(Number(r.tiempo)) &&
      safeInt(r.valor) > 0
    );
  }

  // Agrega (suma) duplicados por (trat, estado, tiempo)
  function buildTemporalCube(rows){
    const cube = {}; // cube[trat][time] = [a,e,i]
    for (const r0 of rows){
      const trat = String(r0.tratamiento || '').trim();
      if (!trat) continue;

      const st = normalizeEstado(r0.estado);
      if (!['alimentacion','excitacion','inmovil'].includes(st)) continue;

      const t = Number(r0.tiempo);
      if (!Number.isFinite(t)) continue;

      const v = safeInt(r0.valor);
      if (v <= 0) continue;

      if (!cube[trat]) cube[trat] = {};
      const key = String(t);

      if (!cube[trat][key]) cube[trat][key] = [0,0,0];
      const idx = st === 'alimentacion' ? 0 : (st === 'excitacion' ? 1 : 2);
      cube[trat][key][idx] += v;
    }
    return cube;
  }

  // Deriva 3√óK total desde temporal
  function derive3xKFromTemporal(namesPreferred){
    const cube = buildTemporalCube(temporalRows);
    const names = (namesPreferred && namesPreferred.length)
      ? namesPreferred
      : Object.keys(cube);

    const feed = [];
    const excit = [];
    const immob = [];

    for (const n of names){
      const byTime = cube[n] || {};
      let a=0,e=0,i=0;
      for (const k of Object.keys(byTime)){
        const v = byTime[k] || [0,0,0];
        a += safeInt(v[0]); e += safeInt(v[1]); i += safeInt(v[2]);
      }
      feed.push(a);
      excit.push(e);
      immob.push(i);
    }
    return { names, raw3: { feed, excit, immob }, cube };
  }

  // Aplicar 3√óK al UI (cuando temporal manda)
  function setTableFrom3xK(names, feed, excit, immob){
    while (colCount() > names.length) removeLastColumn();
    while (colCount() < names.length) addColumn('');

    [...headRow.querySelectorAll('input[data-role="colname"]')]
      .forEach((el, idx)=> el.value = names[idx] ?? `Tratamiento ${idx+1}`);

    [...rowFeed.querySelectorAll('input[data-role="feed"]')]
      .forEach((el, idx)=> el.value = feed[idx] ?? 0);

    [...rowExcit.querySelectorAll('input[data-role="excit"]')]
      .forEach((el, idx)=> el.value = excit[idx] ?? 0);

    [...rowImmob.querySelectorAll('input[data-role="immob"]')]
      .forEach((el, idx)=> el.value = immob[idx] ?? 0);
  }

  // =========================
  // Render outputs
  // =========================
  function renderExpected(names, E){
    let html = '<table class="table table-sm align-middle">';
    html += '<thead><tr><th>Fila</th>' + names.map(n=>`<th>${escapeHtml(n)}</th>`).join('') + '</tr></thead>';
    html += '<tbody>';
    html += '<tr><th>Alimentaci√≥n</th>' + E[0].map(x=>`<td>${fmt(x,2)}</td>`).join('') + '</tr>';
    html += '<tr><th>No_alimentaci√≥n</th>' + E[1].map(x=>`<td>${fmt(x,2)}</td>`).join('') + '</tr>';
    html += '</tbody></table>';
    return html;
  }

  function renderResiduals(names, Z, P, Pbonf, Pholm){
    const K = names.length;

    function rowHtml(label, i){
      let cells = '';
      for (let j=0;j<K;j++){
        cells += `
          <td>
            <div><span class="small-muted">z</span> ${fmt(Z[i][j],2)}</div>
            <div><span class="small-muted">p</span> ${fmt(P[i][j],3)}</div>
            <div><span class="small-muted">p_bonf</span> ${fmt(Pbonf[i][j],3)}</div>
            <div><span class="small-muted">p_holm</span> ${fmt(Pholm[i][j],3)}</div>
          </td>
        `;
      }
      return `<tr><th>${label}</th>${cells}</tr>`;
    }

    let html = '<table class="table table-sm align-middle">';
    html += '<thead><tr><th>Fila</th>' + names.map(n=>`<th>${escapeHtml(n)}</th>`).join('') + '</tr></thead>';
    html += '<tbody>';
    html += rowHtml('Alimentaci√≥n', 0);
    html += rowHtml('No_alimentaci√≥n', 1);
    html += '</tbody></table>';
    return html;
  }

  function renderGlobal({chi2, p, dof, V, pctBelow5, anyBelow1, fisher, temporalUsed}){
    const warn1 = anyBelow1 ? pill('Esperado < 1: S√≠', 'bad') : pill('Esperado < 1: No', 'ok');
    const warn5 = (pctBelow5 > 20) ? pill(`Esperados < 5: ${pctBelow5.toFixed(1)}%`, 'warn') : pill(`Esperados < 5: ${pctBelow5.toFixed(1)}%`, 'ok');
    const src = temporalUsed ? pill('Fuente: Temporal (1B)', 'ok') : pill('Fuente: 3√óK manual (1A)', 'warn');

    const labelP = (pv) => {
      if (!Number.isFinite(pv)) return 'No disponible.';
      if (pv < 0.001) return 'Diferencias MUY claras (casi seguro no es azar).';
      if (pv < 0.05)  return 'Hay diferencias (p < 0.05).';
      return 'No se detectan diferencias claras entre tratamientos.';
    };

    const labelV = (v) => {
      if (!Number.isFinite(v)) return 'No disponible.';
      if (v < 0.10) return 'Impacto peque√±o (cambio leve).';
      if (v < 0.30) return 'Impacto bajo a moderado.';
      if (v < 0.50) return 'Impacto moderado (relevante).';
      return 'Impacto grande (muy marcado).';
    };

    const labelExpected = () => {
      if (anyBelow1) return '‚ö†Ô∏è Hay celdas con esperado < 1: interpretar con cautela.';
      if (pctBelow5 > 20) return '‚ö†Ô∏è Muchos esperados < 5: interpretar con cautela.';
      return '‚úÖ Los supuestos del test se cumplen bien.';
    };

    return `
      <div class="d-flex flex-wrap gap-2 mb-2">${src} ${warn1} ${warn5}</div>
      <div class="small-muted mb-3">${labelExpected()}</div>

      <div class="row g-2">
        <div class="col-md-6">
          <div class="small-muted">Chi-cuadrado</div>
          <div class="h5 mb-0">œá¬≤(${dof}) = ${fmt(chi2,3)}</div>
        </div>

        <div class="col-md-6">
          <div class="small-muted">p-value (œá¬≤)</div>
          <div class="h5 mb-0">p = ${fmtP(p)}</div>
          <div class="small-muted">${labelP(p)}</div>
        </div>

        <div class="col-md-6 mt-2">
          <div class="small-muted">V de Cram√©r</div>
          <div class="h6 mb-0">${fmt(V,3)} <span class="small-muted">(‚âà0.1 peque√±o, 0.3 mediano, 0.5 grande)</span></div>
          <div class="small-muted">${labelV(V)}</div>
        </div>

        <div class="col-md-6 mt-2">
          <div class="small-muted">Fisher‚ÄìFreeman‚ÄìHalton (MC)</div>
          <div class="h6 mb-0">œá¬≤‚âà${fmt(fisher.chiObs,3)}, p‚âà${fmtP(fisher.p)}</div>
        </div>
      </div>
    `;
  }

  function buildSummary(names, obs, Z, P, Pholm){
    const feed = obs[0];
    const totals = names.map((_,j)=> obs[0][j] + obs[1][j]);
    const props = names.map((_,j)=> feed[j] / totals[j]);

    const idx = props.map((v,i)=>({i,v})).sort((a,b)=>b.v-a.v).map(x=>x.i);

    return idx.map(j => ({
      tratamiento: names[j],
      prop_alim: props[j],
      z_alim: Z[0][j],
      p_alim: P[0][j],
      p_holm_alim: Pholm[0][j]
    }));
  }

  function renderProps(rows){
    const lines = rows.map(r => `
      <div class="d-flex justify-content-between gap-2">
        <div>${escapeHtml(r.tratamiento)}</div>
        <div><b>${(r.prop_alim*100).toFixed(1)}%</b></div>
      </div>
    `).join('');
    return `<div class="small-muted mb-2">Proporci√≥n de Alimentaci√≥n por tratamiento (ordenado desc.)</div>${lines}`;
  }

  function drawBarChart(rows, fisherLine){
    const labels = rows.map(r => r.tratamiento);
    const data = rows.map(r => r.prop_alim);

    const ctx = document.getElementById('barChart');
    if (chart) chart.destroy();

    chart = new Chart(ctx, {
      type: 'bar',
      data: { labels, datasets: [{ label: 'Proporci√≥n de Alimentaci√≥n', data, borderWidth: 1 }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true, labels: { color: '#111827', font: { size: 13 } } },
          title: {
            display: true,
            text: ['Proporci√≥n de Alimentaci√≥n por Tratamiento', fisherLine],
            color: '#111827',
            font: { size: 14, weight: 'bold' },
            padding: { bottom: 10 }
          },
          tooltip: { callbacks: { label: (ctx) => ` ${(ctx.raw*100).toFixed(1)}%` } }
        },
        scales: {
          y: { beginAtZero: true, max: 1, ticks: { callback: (v) => `${Math.round(v*100)}%`, color: '#111827' }, grid: { color: '#d1d5db' } },
          x: { ticks: { color: '#111827', maxRotation: 20, minRotation: 20 }, grid: { display: false } }
        }
      }
    });
  }

  // 100% apilado por tratamiento usando 3√óK (sea manual o derivado)
  function drawBehaviorChartFrom3K(names, feed, excit, immob){
    const totals = names.map((_,j)=> safeInt(feed[j]) + safeInt(excit[j]) + safeInt(immob[j]));
    if (totals.some(t => t === 0)) throw new Error('Hay tratamientos con total 0 en 3√óK.');

    const pA = names.map((_,j)=> safeInt(feed[j])  / totals[j]);
    const pE = names.map((_,j)=> safeInt(excit[j]) / totals[j]);
    const pI = names.map((_,j)=> safeInt(immob[j]) / totals[j]);

    const canvas = document.getElementById('behavChart');
    if (!canvas) return;
    if (behavChart) behavChart.destroy();

    behavChart = new Chart(canvas, {
      type: 'bar',
      data: {
        labels: names,
        datasets: [
          { label:'Alimentaci√≥n', data: pA, stack:'s1', borderWidth: 1 },
          { label:'Excitaci√≥n',   data: pE, stack:'s1', borderWidth: 1 },
          { label:'Inm√≥vil',      data: pI, stack:'s1', borderWidth: 1 },
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins:{
          title:{ display:true, text:'Distribuci√≥n de estados por tratamiento (100% apilado)', color:'#111827', font:{size:14, weight:'bold'} },
          legend:{ labels:{ color:'#111827' } },
          tooltip:{ callbacks:{ label:(ctx)=>` ${ctx.dataset.label}: ${(ctx.raw*100).toFixed(1)}%` } }
        },
        scales:{
          x:{ stacked:true, ticks:{ color:'#111827', maxRotation:20, minRotation:20 }, grid:{ display:false } },
          y:{ stacked:true, min:0, max:1, ticks:{ callback:(v)=>`${Math.round(v*100)}%`, color:'#111827' }, grid:{ color:'#e5e7eb' } }
        }
      }
    });
  }

  // =========================
  // √Åreas acumuladas por tratamiento (desde temporal cube)
  // cube[trat][time] = [a,e,i]
  // =========================
  function destroyAreaCharts(){
    areaCharts.forEach(ch => { try { ch.destroy(); } catch(e){} });
    areaCharts = [];
    const wrap = document.getElementById('areaChartsWrap');
    if (wrap) wrap.innerHTML = '';
  }

  function drawAreaCumulativeChartsByTreatment(names, cube){
    const wrap = document.getElementById('areaChartsWrap');
    if (!wrap) return;

    destroyAreaCharts();

    const keys = names.filter(k => cube && cube[k] && Object.keys(cube[k]).length);
    if (!keys.length){
      wrap.innerHTML = `<div class="small-muted">No hay serie temporal cargada para graficar √°reas acumuladas.</div>`;
      return;
    }

    keys.forEach((treatName, idx) => {
      const seriesObj = cube[treatName] || {};
      const times = Object.keys(seriesObj).map(Number).filter(Number.isFinite).sort((a,b)=>a-b);
      if (!times.length) return;

      let cA = 0, cE = 0, cI = 0;
      const dataA = [], dataE = [], dataI = [];
      times.forEach(t => {
        const v = seriesObj[String(t)] || [0,0,0];
        cA += safeInt(v[0]);
        cE += safeInt(v[1]);
        cI += safeInt(v[2]);
        dataA.push({x: t, y: cA});
        dataE.push({x: t, y: cE});
        dataI.push({x: t, y: cI});
      });

      const card = document.createElement('div');
      card.className = 'chart-wrap';
      card.style.height = '280px';
      card.innerHTML = `<canvas id="areaChart_${idx}"></canvas>`;
      wrap.appendChild(card);

      const canvas = document.getElementById(`areaChart_${idx}`);
      const ch = new Chart(canvas, {
        type: 'line',
        data: {
          datasets: [
            { label: 'Alimentaci√≥n (acum)', data: dataA, fill: true, borderWidth: 1, tension: 0.25 },
            { label: 'Excitaci√≥n (acum)',   data: dataE, fill: true, borderWidth: 1, tension: 0.25 },
            { label: 'Inm√≥vil (acum)',      data: dataI, fill: true, borderWidth: 1, tension: 0.25 },
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          plugins: {
            title: { display: true, text: `Acumulado por estado ‚Äî ${treatName}`, color: '#111827', font: { size: 14, weight: 'bold' } },
            legend: { labels: { color: '#111827' } },
            tooltip: { callbacks: { label: (ctx) => ` ${ctx.dataset.label}: ${ctx.raw.y}` } }
          },
          scales: {
            x: { type: 'linear', title: { display: true, text: 'Tiempo', color: '#111827' }, ticks: { color: '#111827' }, grid: { color: '#e5e7eb' } },
            y: { stacked: true, beginAtZero: true, title: { display: true, text: 'Conteo acumulado', color: '#111827' }, ticks: { color: '#111827' }, grid: { color: '#e5e7eb' } }
          },
          elements: { point: { radius: 2 } }
        }
      });

      areaCharts.push(ch);
    });
  }

  // =========================
  // CSV resumen descarga
  // =========================
  function downloadCSV(rows){
    const header = ['tratamiento','prop_alim','z_alim','p_alim','p_holm_alim'];
    const csv = [header.join(',')].concat(
      rows.map(r => {
        const vals = [
          `"${String(r.tratamiento).replaceAll('"','""')}"`,
          r.prop_alim,
          r.z_alim,
          r.p_alim,
          r.p_holm_alim
        ];
        return vals.join(',');
      })
    ).join('\n');

    const blob = new Blob([csv], {type: 'text/csv;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'resumen_alimentacion.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // =========================
  // Upload Excel/CSV 3√óK
  // =========================
  async function loadExcel3xK(file){
    const ext = file.name.toLowerCase().split('.').pop();

    if (ext === 'csv'){
      const text = await file.text();
      const lines = text.split(/\r?\n/).filter(l=>l.trim().length);

      const commaCount = (lines[0].match(/,/g) || []).length;
      const semiCount  = (lines[0].match(/;/g) || []).length;
      const delim = semiCount > commaCount ? ';' : ',';

      const header = lines[0].split(delim).map(x=>x.trim());
      const names = header.slice(1);

      const map = {alimentacion: [], excitacion: [], inmovil: []};

      for (let i=1;i<lines.length;i++){
        const parts = lines[i].split(delim).map(x=>x.trim());
        const estado = normalizeEstado(parts[0]);
        const vals = parts.slice(1).map(v => safeInt(v));
        if (map[estado]) map[estado] = vals;
      }

      if (!map.alimentacion.length || !map.excitacion.length || !map.inmovil.length){
        throw new Error('El CSV debe tener 3 filas: alimentaci√≥n, excitaci√≥n e inmovil.');
      }

      setTableFrom3xK(names, map.alimentacion, map.excitacion, map.inmovil);
      return;
    }

    const buf = await file.arrayBuffer();
    const wb = XLSX.read(buf, {type:'array'});
    const ws = wb.Sheets[wb.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(ws, {defval: ''});

    const cols = Object.keys(rows[0] || {});
    const estadoCol = cols.find(c => String(c).toLowerCase().trim() === 'estado');
    if (!estadoCol) throw new Error('El Excel 3√óK debe tener una columna llamada "estado".');

    const names = cols.filter(c => c !== estadoCol);

    const map = {alimentacion: [], excitacion: [], inmovil: []};
    for (const r of rows){
      const estado = normalizeEstado(r[estadoCol]);
      const vals = names.map(n => safeInt(r[n]));
      if (map[estado]) map[estado] = vals;
    }

    if (!map.alimentacion.length || !map.excitacion.length || !map.inmovil.length){
      throw new Error('El Excel 3√óK debe tener 3 filas: alimentaci√≥n, excitaci√≥n e inmovil.');
    }

    setTableFrom3xK(names, map.alimentacion, map.excitacion, map.inmovil);
  }

  // =========================
  // Upload Excel/CSV TEMPORAL
  // Requiere columnas: tratamiento, estado, tiempo, valor
  // =========================
  async function loadTemporalFile(file){
    const ext = file.name.toLowerCase().split('.').pop();
    let rows = [];

    if (ext === 'csv'){
      const text = await file.text();
      const lines = text.split(/\r?\n/).filter(l=>l.trim().length);

      const commaCount = (lines[0].match(/,/g) || []).length;
      const semiCount  = (lines[0].match(/;/g) || []).length;
      const delim = semiCount > commaCount ? ';' : ',';

      const header = lines[0].split(delim).map(x=>x.trim().toLowerCase());
      const idxT = header.indexOf('tratamiento');
      const idxE = header.indexOf('estado');
      const idxTime = header.indexOf('tiempo');
      const idxV = header.indexOf('valor');

      if (idxT<0 || idxE<0 || idxTime<0 || idxV<0){
        throw new Error('CSV temporal requiere columnas: tratamiento, estado, tiempo, valor.');
      }

      for (let i=1;i<lines.length;i++){
        const parts = lines[i].split(delim).map(x=>x.trim());
        rows.push({
          tratamiento: parts[idxT],
          estado: normalizeEstado(parts[idxE]),
          tiempo: Number(parts[idxTime]),
          valor: safeInt(parts[idxV])
        });
      }
    } else {
      const buf = await file.arrayBuffer();
      const wb = XLSX.read(buf, {type:'array'});
      const ws = wb.Sheets[wb.SheetNames[0]];
      const json = XLSX.utils.sheet_to_json(ws, {defval: ''});

      const cols = Object.keys(json[0] || {}).map(c => String(c).toLowerCase().trim());
      const findCol = (name) => Object.keys(json[0] || {}).find(c => String(c).toLowerCase().trim() === name);

      const cT = findCol('tratamiento');
      const cE = findCol('estado');
      const cTime = findCol('tiempo');
      const cV = findCol('valor');

      if (!cT || !cE || !cTime || !cV){
        throw new Error('Excel temporal requiere columnas: tratamiento, estado, tiempo, valor.');
      }

      rows = json.map(r => ({
        tratamiento: String(r[cT] ?? '').trim(),
        estado: normalizeEstado(r[cE]),
        tiempo: Number(r[cTime]),
        valor: safeInt(r[cV])
      }));
    }

    // set temporal
    temporalRows = rows.filter(r => String(r.tratamiento||'').trim().length);
    if (!temporalRows.length) throw new Error('Archivo temporal vac√≠o o sin tratamientos v√°lidos.');

    renderTemporalTable();
  }

  // =========================
  // Ejemplo (carga 3√óK + temporal)
  // =========================
  function loadExample(){
    while (colCount() > 4) removeLastColumn();
    while (colCount() < 4) addColumn('');

    const names = [
      'Control KAT ES',
      'T1 Katal ES + premix ajo 10 kg/tm',
      'T2 Katal ES + Premix ajo china 10 kg/tm',
      'T3 Katal ES + 2 Kg/tm Citoprac'
    ];

    // Temporal demo (6 tiempos)
    const times = [5,10,15,20,25,30];

    // Genero algo coherente: suma temporal = 3√óK
    temporalRows = [];
    names.forEach((tr, j) => {
      times.forEach((t, k) => {
        // patr√≥n simple diferente por tratamiento
        const a = [2,1,3,0][j] + (k%2);
        const e = [6,5,4,7][j] + (k%3);
        const i = [3,4,2,5][j] + ((k+1)%2);

        temporalRows.push({tratamiento: tr, estado:'alimentacion', tiempo:t, valor:a});
        temporalRows.push({tratamiento: tr, estado:'excitacion',   tiempo:t, valor:e});
        temporalRows.push({tratamiento: tr, estado:'inmovil',      tiempo:t, valor:i});
      });
    });

    renderTemporalTable();

    // Deriva 3√óK desde temporal y setea UI
    const d = derive3xKFromTemporal(names);
    setTableFrom3xK(d.names, d.raw3.feed, d.raw3.excit, d.raw3.immob);
  }

  // =========================
  // Sync tratamientos temporal desde 3√óK
  // (si renombraste arriba, rellena filas vac√≠as o reemplaza nombres id√©nticos "Tratamiento X")
  // =========================
  function syncTemporalNamesFrom3xK(){
    const names = getTreatmentNamesFrom3xK();
    if (!temporalRows.length){
      // crea 1 fila por estado por cada tratamiento en t=0
      names.forEach(n=>{
        ['alimentacion','excitacion','inmovil'].forEach(st=>{
          temporalRows.push({tratamiento:n, estado:st, tiempo:0, valor:0});
        });
      });
      renderTemporalTable();
      return;
    }

    // Si un tratamiento temporal no existe en 3√óK pero parece placeholder, lo mapeo por orden
    const uniqTemp = [...new Set(temporalRows.map(r => String(r.tratamiento||'').trim()).filter(Boolean))];
    const isPlaceholder = (s) => /^tratamiento\s*\d+$/i.test(String(s||'').trim());

    // regla simple: si temporal tiene placeholders, los reasigna por orden
    let placeholders = uniqTemp.filter(isPlaceholder);
    if (placeholders.length){
      const map = new Map();
      placeholders.forEach((p, idx)=> { map.set(p, names[idx] ?? p); });
      temporalRows.forEach(r=>{
        const key = String(r.tratamiento||'').trim();
        if (map.has(key)) r.tratamiento = map.get(key);
      });
    }

    renderTemporalTable();
  }

  // =========================
  // RUN (fuente √∫nica)
  // =========================
  async function run(){
    try {
      clearOutputs();

      const alpha = Math.min(0.50, Math.max(0.001, Number(document.getElementById('alpha').value) || 0.05));
      const nSim = Math.max(1000, safeInt(document.getElementById('nSim').value));
      const seed = safeInt(document.getElementById('seed').value);

      let names, raw3, cube;
      let temporalUsed = false;

      // 1) Si hay temporal => fuente √∫nica
      if (hasTemporalData()){
        temporalUsed = true;

        const namesPreferred = getTreatmentNamesFrom3xK(); // respeta orden/nombres del header si quieres
        const d = derive3xKFromTemporal(namesPreferred);
        names = d.names;
        raw3 = d.raw3;
        cube = d.cube;

        // Refresca UI 3√óK para que todo coincida visualmente
        setTableFrom3xK(names, raw3.feed, raw3.excit, raw3.immob);
      } else {
        // 2) fallback a 3√óK manual
        const t = read3xKTableManual();
        names = t.names;
        raw3 = t.raw3;
        cube = null;
      }

      // Construye 2√óK
      const feed = raw3.feed.map(safeInt);
      const nofeed = raw3.excit.map((v,i)=> safeInt(v) + safeInt(raw3.immob[i]));
      const obs = [feed, nofeed];

      const N = sum(feed) + sum(nofeed);
      if (N === 0) throw new Error('No hay datos (N=0).');

      const colTotals = names.map((_,j)=> feed[j] + nofeed[j]);
      if (colTotals.some(t => t === 0)){
        throw new Error('Hay tratamientos con total 0. Revisa tus datos.');
      }

      // Chi2 global
      const {chi2, p, dof, E, V} = chiSquare2xK(obs);
      const flatE = [...E[0], ...E[1]];
      const pctBelow5 = flatE.filter(x => x < 5).length / flatE.length * 100;
      const anyBelow1 = flatE.some(x => x < 1);

      const Z = stdResiduals(obs, E);
      const P = pvalsFromZ(Z);
      const Pbonf = bonferroni(P);
      const Pholm = holm(P);

      const fisher = fisherMC2xK(obs, nSim, seed);

      document.getElementById('globalOut').innerHTML = renderGlobal({chi2, p, dof, V, pctBelow5, anyBelow1, fisher, temporalUsed});
      document.getElementById('expectedWrap').innerHTML = renderExpected(names, E);
      document.getElementById('residWrap').innerHTML = renderResiduals(names, Z, P, Pbonf, Pholm);

      const summaryRows = buildSummary(names, obs, Z, P, Pholm);
      lastSummaryRows = summaryRows;
      document.getElementById('propOut').innerHTML = renderProps(summaryRows);

      drawBarChart(summaryRows, `Fisher‚ÄìFreeman‚ÄìHalton (MC): œá¬≤‚âà${fmt(fisher.chiObs,3)}, p‚âà${fmtP(fisher.p)}`);
      drawBehaviorChartFrom3K(names, raw3.feed, raw3.excit, raw3.immob);

      // √Åreas acumuladas (solo si temporal)
      if (cube){
        drawAreaCumulativeChartsByTreatment(names, cube);
      } else {
        destroyAreaCharts();
        document.getElementById('areaChartsWrap').innerHTML = `<div class="small-muted">Carga serie temporal (1B) para ver √°reas acumuladas.</div>`;
      }

      // Pares y potencia
      const pairs = pairwiseComparisons(names, obs, alpha);
      document.getElementById('pairsWrap').innerHTML = renderPairsTable(pairs.rows, alpha);
      document.getElementById('pMatWrap').innerHTML  = renderPMatrix(names, pairs.pMat, alpha);
      document.getElementById('powerWrap').innerHTML = renderPowerTable(pairs.powerRows);

    } catch (err){
      alert(err?.message ?? String(err));
      console.error(err);
    }
  }

  // =========================
  // Eventos
  // =========================
  btnAddCol.addEventListener('click', () => addColumn('Tratamiento'));
  btnRemoveCol.addEventListener('click', removeLastColumn);

  document.getElementById('btnClear').addEventListener('click', () => clearAll());

  document.getElementById('btnExample').addEventListener('click', () => {
    loadExample();
    run();
  });

  document.getElementById('btnRun').addEventListener('click', run);

  document.getElementById('btnDownloadCSV').addEventListener('click', () => {
    if (!lastSummaryRows) return alert('Primero presiona Calcular.');
    downloadCSV(lastSummaryRows);
  });

  document.getElementById('fileExcel').addEventListener('change', async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    try{
      await loadExcel3xK(f);
      await run();
    }catch(err){
      alert(err?.message ?? String(err));
      console.error(err);
    }finally{
      e.target.value = '';
    }
  });

  document.getElementById('fileTemporal').addEventListener('change', async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    try{
      await loadTemporalFile(f);
      await run();
    }catch(err){
      alert(err?.message ?? String(err));
      console.error(err);
    }finally{
      e.target.value = '';
    }
  });

  document.getElementById('btnAddTempRow').addEventListener('click', () => addTemporalRow());
  document.getElementById('btnRemoveTempRow').addEventListener('click', () => removeTemporalRow());

  document.getElementById('btnSyncTemporalNames').addEventListener('click', () => {
    syncTemporalNamesFrom3xK();
  });

  document.getElementById('btnClearTemporal').addEventListener('click', () => {
    temporalRows = [];
    renderTemporalTable();
    run();
  });

  // init
  clearAll();
  loadExample();
  run();
</script>

<!-- Bootstrap JS (necesario para tabs) -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
