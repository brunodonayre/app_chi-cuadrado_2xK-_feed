<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>App 2√óK: Alimentaci√≥n vs No-alimentaci√≥n (desde serie temporal)</title>

  <!-- Bootstrap (solo UI) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- jStat -->
  <script src="https://cdn.jsdelivr.net/npm/jstat@1.9.6/dist/jstat.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <!-- SheetJS para leer Excel .xlsx -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    body { background: #0b1220; }
    .card { border: 0; border-radius: 16px; }
    .form-control, .form-select { background: #0b1220; color: #e5e7eb; border-color: #243146; }
    .form-control:focus, .form-select:focus { box-shadow: none; border-color: #3b82f6; }
    .btn-primary { border-radius: 12px; }
    .btn-outline-light, .btn-outline-danger { border-radius: 12px; }
    .small-muted { color: #94a3b8; }
    .pill { display:inline-block; padding:.15rem .5rem; border-radius:999px; font-size:.8rem; }
    .pill-ok { background:#064e3b; color:#a7f3d0; }
    .pill-warn { background:#7c2d12; color:#fed7aa; }
    .pill-bad { background:#7f1d1d; color:#fecaca; }

    /* Cards siguen oscuras, tablas en blanco */
    .card { background: #0f172a; color: #e5e7eb; }
    .table { background: #ffffff; color: #000000; }

    /* Encabezados tablas */
    .table thead th{
      background: #001A72;
      color: #ffffff;
      border-color: #001A72 !important;
    }

    /* Celdas */
    .table tbody td, .table tbody th{
      color: #000000;
      background: #ffffff;
      border-color: #d0d7de;
    }

    /* Rayado suave */
    .table tbody tr:nth-child(even) td,
    .table tbody tr:nth-child(even) th{
      background: #f6f8fa;
    }

    .table thead tr { background: #001A72; }

    .table { border-collapse: separate; border-spacing: 0; }

    .table th, .table td{
      border-right: 2px solid #9aa4b2 !important;
      border-bottom: 1px solid #c7ced8 !important;
    }

    .table tr > *:first-child{
      border-left: 2px solid #9aa4b2 !important;
    }

    .table thead tr > *{
      border-top: 2px solid #001A72 !important;
    }

    .table tbody tr:hover td,
    .table tbody tr:hover th{
      background: #eef2ff;
    }

    code { color:#93c5fd; }

    /* Tabs */
    .nav-tabs { border-bottom: 0; }
    .nav-tabs .nav-link { color:#e5e7eb; border:0; border-bottom:2px solid transparent; background: transparent; }
    .nav-tabs .nav-link.active { color:#ffffff; border-bottom:2px solid #3b82f6; background: transparent; }

    /* ===== Chart: evita colapso y fondo blanco ===== */
    .chart-wrap{
      position: relative;
      width: 100%;
      height: 320px;
      min-height: 260px;
      background: #ffffff;
      border-radius: 12px;
      padding: 10px;
      overflow: hidden;
    }

    canvas{
      width: 100% !important;
      height: 100% !important;
      display: block;
      background: #ffffff;
      border-radius: 10px;
    }
  </style>
</head>

<body>
<div class="container py-4">
  <div class="row g-3">

    <!-- Header -->
    <div class="col-12">
      <div class="card p-4">
        <div class="d-flex flex-wrap gap-2 align-items-center justify-content-between">
          <div>
            <h1 class="h4 mb-1">App 2√óK: Alimentaci√≥n vs No-alimentaci√≥n (desde serie temporal)</h1>
            <div class="small-muted">
              Fuente √∫nica: <b>serie temporal</b> con columnas:
              <code>tratamiento, estado, tiempo, valor</code>.
              <br/>
              La app construye 3√óK por suma temporal y colapsa autom√°ticamente:
              <code>No_alimentaci√≥n = Excitaci√≥n + Inm√≥vil</code>, y calcula œá¬≤, V de Cram√©r,
              residuos z, correcciones (Bonferroni/Holm), Fisher‚ÄìFreeman‚ÄìHalton (Monte Carlo),
              comparaciones por pares (Fisher 2√ó2), matriz p-values y potencia estimada.
            </div>
          </div>
          <div class="d-flex gap-2">
            <button class="btn btn-outline-light" id="btnExample">Cargar ejemplo</button>
            <button class="btn btn-outline-light" id="btnClear">Limpiar</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Tabs -->
    <div class="col-12">
      <ul class="nav nav-tabs" id="mainTabs" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link active" id="tab-analisis" data-bs-toggle="tab"
                  data-bs-target="#pane-analisis" type="button" role="tab" aria-controls="pane-analisis" aria-selected="true">
            An√°lisis
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="tab-manual" data-bs-toggle="tab"
                  data-bs-target="#pane-manual" type="button" role="tab" aria-controls="pane-manual" aria-selected="false">
            üìò Manual
          </button>
        </li>
      </ul>
    </div>

    <!-- Tab content wrapper -->
    <div class="col-12">
      <div class="tab-content" id="mainTabsContent">

        <!-- ===================== -->
        <!-- PANE: AN√ÅLISIS -->
        <!-- ===================== -->
        <div class="tab-pane fade show active" id="pane-analisis" role="tabpanel" aria-labelledby="tab-analisis">
          <div class="row g-3">

            <!-- Entrada -->
            <div class="col-12">
              <div class="card p-4">
                <div class="d-flex flex-wrap gap-2 align-items-center justify-content-between mb-2">
                  <h2 class="h6 mb-0">1) Serie temporal (fuente √∫nica)</h2>
                </div>

                <div class="row g-2 mt-2">
                  <div class="col-md-8">
                    <label class="form-label">Subir Excel/CSV</label>
                    <input class="form-control" type="file" id="fileExcel" accept=".xlsx,.xls,.csv" />
                    <div class="small-muted">
                      Recomendado (formato largo): columnas <b>tratamiento</b>, <b>estado</b>, <b>tiempo</b>, <b>valor</b>.
                      <br/>
                      Legacy soportado (3√óK): columna <b>estado</b> + columnas por tratamiento (se convierte a <b>tiempo=0</b>).
                    </div>
                  </div>
                </div>

                <div class="row g-3 mt-3">
                  <div class="col-md-3">
                    <label class="form-label">Simulaciones Fisher MC</label>
                    <input class="form-control" id="nSim" type="number" min="1000" step="1000" value="100000" />
                    <div class="small-muted">M√°s simulaciones = p m√°s estable (pero m√°s lento).</div>
                  </div>
                  <div class="col-md-3">
                    <label class="form-label">Semilla</label>
                    <input class="form-control" id="seed" type="number" step="1" value="123" />
                    <div class="small-muted">Cambia la semilla si quieres otra corrida reproducible.</div>
                  </div>
                  <div class="col-md-3">
                    <label class="form-label">Nivel de significancia (Œ±)</label>
                    <input class="form-control" id="alpha" type="number" min="0.001" max="0.50" step="0.01" value="0.05" />
                    <div class="small-muted">Usual: 0.05 (5%).</div>
                  </div>
                  <div class="col-md-3 d-flex align-items-end">
                    <button class="btn btn-primary w-100" id="btnRun">Calcular</button>
                  </div>
                </div>

                <div class="small-muted mt-3">
                  Nota: la tabla 3√óK se calcula como suma temporal, y el an√°lisis global se hace sobre 2√óK:
                  <b>No_alimentaci√≥n = Excitaci√≥n + Inm√≥vil</b>.
                </div>

              </div>
            </div>

            <!-- Tabla 3√óK derivada -->
            <div class="col-12">
              <div class="card p-4">
                <h2 class="h6 mb-2">1.1) Tabla observada (3 estados) ‚Äî derivada de la serie temporal</h2>
                <div class="table-responsive" id="obs3kWrap"></div>
              </div>
            </div>

            <!-- Resultados -->
            <div class="col-12 col-lg-6">
              <div class="card p-4 h-100">
                <h2 class="h6">2) Resultados globales (2√óK)</h2>
                <div id="globalOut" class="mt-2"></div>
                <hr class="border-secondary" />
                <h2 class="h6">3) Esperados (E)</h2>
                <div class="table-responsive" id="expectedWrap"></div>
              </div>
            </div>

            <div class="col-12 col-lg-6">
              <div class="card p-4 h-100">
                <h2 class="h6">4) Proporci√≥n de Alimentaci√≥n y gr√°ficos</h2>
                <div id="propOut" class="mt-2"></div>

                <div class="mt-3 chart-wrap">
                  <canvas id="barChart"></canvas>
                </div>

                <div class="mt-4 chart-wrap">
                  <canvas id="behavChart"></canvas>
                </div>

                <div class="mt-4">
                  <div class="small-muted mb-2">√Åreas apiladas (100% por tiempo) por tratamiento</div>
                  <div id="areaChartsWrap" class="d-grid gap-3"></div>
                </div>

                <div class="mt-4">
                  <div class="small-muted mb-2">√Åreas apiladas (100% por tiempo) promedio global</div>
                  <div class="chart-wrap">
                    <canvas id="areaChartGlobal"></canvas>
                  </div>
                </div>

                <div class="d-flex gap-2 mt-3">
                  <button class="btn btn-outline-light" id="btnDownloadCSV">Descargar resumen CSV</button>
                </div>
              </div>
            </div>

            <div class="col-12">
              <div class="card p-4">
                <h2 class="h6">5) Residuos z y p-values por celda (2√óK)</h2>
                <div class="table-responsive" id="residWrap"></div>
                <div class="small-muted mt-2">Regla orientativa: |z| &gt; 1.96 ‚âà p &lt; 0.05 (sin correcci√≥n).</div>
              </div>
            </div>

            <!-- Comparaciones por pares -->
            <div class="col-12">
              <div class="card p-4">
                <h2 class="h6">6) Comparaciones por pares (Fisher 2√ó2) + ajuste Holm</h2>
                <div class="small-muted mb-2">
                  Se eval√∫a significancia por <b>p_fisher</b> y por <b>p_holm</b> usando Œ± (arriba).
                </div>
                <div class="table-responsive" id="pairsWrap"></div>
              </div>
            </div>

            <div class="col-12">
              <div class="card p-4">
                <h2 class="h6">7) Matriz de p-values (Fisher 2√ó2, sin ajustar)</h2>
                <div class="small-muted mb-2">
                  * indica p &lt; Œ± (seg√∫n el Œ± ingresado arriba).
                </div>
                <div class="table-responsive" id="pMatWrap"></div>
              </div>
            </div>

            <div class="col-12">
              <div class="card p-4">
                <h2 class="h6">8) Potencia estimada por comparaci√≥n (aprox.)</h2>
                <div class="small-muted mb-2">
                  Estimaci√≥n aproximada (normal) usando diferencia de proporciones y n observados.
                </div>
                <div class="table-responsive" id="powerWrap"></div>
              </div>
            </div>

          </div><!-- /row g-3 -->
        </div><!-- /pane-analisis -->

        <!-- ===================== -->
        <!-- PANE: MANUAL -->
        <!-- ===================== -->
        <div class="tab-pane fade" id="pane-manual" role="tabpanel" aria-labelledby="tab-manual">
          <div class="card p-4 mt-3">
            <h2 class="h6 mb-2">üìò Manual de interpretaci√≥n</h2>
            <div class="small-muted mb-3">Gu√≠a r√°pida para leer los resultados de la app.</div>

            <h3 class="h6 mt-3">Entrada (serie temporal)</h3>
            <div>
              Sube un Excel/CSV con columnas:
              <code>tratamiento, estado, tiempo, valor</code>.
              <br/>
              Estados aceptados (se normalizan): <b>Alimentaci√≥n</b>, <b>Excitaci√≥n</b>, <b>Inm√≥vil</b>.
              La tabla 3√óK se calcula como suma en el tiempo y el an√°lisis global se hace en 2√óK:
              <code>No_alimentaci√≥n = Excitaci√≥n + Inm√≥vil</code>.
            </div>

            <h3 class="h6 mt-3">√Åreas apiladas</h3>
            <div>
              Para cada tratamiento, por cada tiempo, se muestran <b>porcentajes</b> (100% apilado):
              <code>p_estado(t) = conteo_estado(t) / (alim+excit+inmov)(t)</code>.
              Si un tiempo tiene total 0, se ignora.
            </div>

            <h3 class="h6 mt-3">Comparaciones por pares</h3>
            <div>
              Se reporta significancia usando:
              <b>p_fisher &lt; Œ±</b> y <b>p_holm &lt; Œ±</b> (dos columnas).
            </div>
          </div>
        </div><!-- /pane-manual -->

      </div><!-- /tab-content -->
    </div><!-- /col-12 tab-content wrapper -->

  </div><!-- /row g-3 -->
</div><!-- /container -->

<script>
  // =========================
  // Utilidades
  // =========================
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const fmt = (x, d=4) => (Number.isFinite(x) ? x.toFixed(d) : 'NA');
  const fmtP = (p) => (Number.isFinite(p) ? (p < 0.0001 ? '<0.0001' : p.toFixed(4)) : 'NA');
  const sum = (arr) => arr.reduce((a,b)=>a+b,0);

  function pill(text, kind){
    const cls = kind === 'ok' ? 'pill-ok' : kind === 'warn' ? 'pill-warn' : 'pill-bad';
    return `<span class="pill ${cls}">${text}</span>`;
  }

  function safeInt(v){
    const n = Number(v);
    if (!Number.isFinite(n) || n < 0) return 0;
    return Math.floor(n);
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  // =========================
  // Estado normalization
  // =========================
  function normalizeEstado(s){
    s = String(s || '').toLowerCase().trim();
    s = s.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    if (s.includes('aliment')) return 'alimentacion';
    if (s.includes('excit')) return 'excitacion';
    if (s.includes('inmov')) return 'inmovil';
    return s;
  }

  // =========================
  // Fuente √∫nica: serie temporal (temporalData)
  // [{tratamiento, estado, tiempo, valor}, ...]
  // =========================
  let temporalData = [];

  // =========================
  // RNG + Hypergeom (para Fisher MC)
  // =========================
  function makeRng(seed){
    let x = (seed >>> 0) || 123456789;
    return function(){
      x ^= x << 13; x >>>= 0;
      x ^= x >> 17; x >>>= 0;
      x ^= x << 5;  x >>>= 0;
      return (x >>> 0) / 4294967296;
    }
  }

  function logFactorial(n){
    if (n < 2) return 0;
    return n*Math.log(n) - n + 0.5*Math.log(2*Math.PI*n) + 1/(12*n) - 1/(360*n*n*n);
  }

  function logChoose(n,k){
    if (k < 0 || k > n) return -Infinity;
    return logFactorial(n) - logFactorial(k) - logFactorial(n-k);
  }

  function hypergeomPmf(x, K, N, n){
    if (x < 0 || x > K || x > n || n-x > (N-K)) return 0;
    const logp = logChoose(K,x) + logChoose(N-K, n-x) - logChoose(N,n);
    return Math.exp(logp);
  }

  function hypergeomSample(rng, K, N, n){
    const xmin = Math.max(0, n - (N - K));
    const xmax = Math.min(n, K);
    let u = rng();
    let c = 0;
    for (let x = xmin; x <= xmax; x++){
      c += hypergeomPmf(x, K, N, n);
      if (u <= c) return x;
    }
    return xmax;
  }

  // =========================
  // C√°lculos 2√óK
  // =========================
  function chiSquare2xK(obs2xK){
    const K = obs2xK[0].length;
    const rowTotals = [sum(obs2xK[0]), sum(obs2xK[1])];
    const colTotals = Array.from({length: K}, (_,j)=> obs2xK[0][j] + obs2xK[1][j]);
    const N = rowTotals[0] + rowTotals[1];

    const E = [[],[]];
    for (let j=0;j<K;j++){
      E[0][j] = rowTotals[0] * colTotals[j] / N;
      E[1][j] = rowTotals[1] * colTotals[j] / N;
    }

    let chi2 = 0;
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++){
        const e = E[i][j];
        if (e > 0) chi2 += (obs2xK[i][j]-e)*(obs2xK[i][j]-e)/e;
      }
    }

    const dof = (2-1)*(K-1);
    const p = 1 - jStat.chisquare.cdf(chi2, dof);

    const denom = Math.min(2-1, K-1);
    const V = denom > 0 ? Math.sqrt(chi2 / (N * denom)) : NaN;

    return {chi2, p, dof, E, N, V};
  }

  function stdResiduals(obs, E){
    const K = obs[0].length;
    const Z = [[],[]];
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++){
        Z[i][j] = (obs[i][j] - E[i][j]) / Math.sqrt(E[i][j]);
      }
    }
    return Z;
  }

  function pvalsFromZ(Z){
    const K = Z[0].length;
    const P = [[],[]];
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++){
        const z = Math.abs(Z[i][j]);
        P[i][j] = 2*(1 - jStat.normal.cdf(z, 0, 1));
      }
    }
    return P;
  }

  function bonferroni(P){
    const K = P[0].length;
    const m = 2*K;
    const out = [[],[]];
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++) out[i][j] = clamp01(P[i][j]*m);
    }
    return out;
  }

  function holm(P){
    const K = P[0].length;
    const m = 2*K;
    const flat = [];
    for (let i=0;i<2;i++) for (let j=0;j<K;j++) flat.push({i,j,p:P[i][j]});
    flat.sort((a,b)=>a.p-b.p);

    let runningMax = 0;
    for (let k=0;k<m;k++){
      const t = k+1;
      const adj = (m - t + 1) * flat[k].p;
      runningMax = Math.max(runningMax, adj);
      flat[k].adj = clamp01(runningMax);
    }

    const out = [Array(K).fill(0), Array(K).fill(0)];
    for (const el of flat){ out[el.i][el.j] = el.adj; }
    return out;
  }

  function fisherMC2xK(obs2xK, nSim=100000, seed=123){
    const K = obs2xK[0].length;
    const colTotals = Array.from({length: K}, (_,j)=> obs2xK[0][j] + obs2xK[1][j]);
    const row1Tot = sum(obs2xK[0]);

    const {chi2: chiObs} = chiSquare2xK(obs2xK);

    const rng = makeRng(seed);
    let countGE = 0;

    for (let s=0; s<nSim; s++){
      let remainingSuccess = row1Tot;
      const remainingCol = colTotals.slice();
      const alloc = new Array(K).fill(0);

      for (let j=0; j<K-1; j++){
        const N = sum(remainingCol);
        const Kgood = remainingCol[j];
        const n = remainingSuccess;
        const x = hypergeomSample(rng, Kgood, N, n);
        alloc[j] = x;
        remainingSuccess -= x;
        remainingCol[j] = 0;
      }
      alloc[K-1] = remainingSuccess;

      const sim = [alloc, colTotals.map((ct,j)=>ct-alloc[j])];
      const {chi2: chiSim} = chiSquare2xK(sim);
      if (chiSim >= chiObs) countGE++;
    }

    return {chiObs, p: countGE / nSim};
  }

  // =========================
  // Fisher exacto 2√ó2 dos colas + OR
  // =========================
  function fisherExactTwoSided(a,b,c,d){
    const r1 = a + b, r2 = c + d;
    const c1 = a + c, c2 = b + d;
    const n  = r1 + r2;

    const OR = ((a+0.5)*(d+0.5))/((b+0.5)*(c+0.5));

    const amin = Math.max(0, r1 - c2);
    const amax = Math.min(r1, c1);

    function logHyp(a0){
      return logChoose(c1, a0) + logChoose(c2, r1-a0) - logChoose(n, r1);
    }

    const pObs = Math.exp(logHyp(a));
    let pTwo = 0;
    for (let x=amin; x<=amax; x++){
      const px = Math.exp(logHyp(x));
      if (px <= pObs + 1e-12) pTwo += px;
    }
    return {OR, p: clamp01(pTwo)};
  }

  function holm1D(pvals){
    const m = pvals.length;
    const order = [...pvals.keys()].sort((i,j)=>pvals[i]-pvals[j]);
    let runningMax = 0;
    const adj = new Array(m).fill(1);
    for (let k=0;k<m;k++){
      const i = order[k];
      const factor = (m - k);
      runningMax = Math.max(runningMax, pvals[i]*factor);
      adj[i] = clamp01(runningMax);
    }
    return adj;
  }

  function pairwiseComparisons(names, obs, alpha){
    const K = names.length;
    const feed = obs[0], nofeed = obs[1];
    const totals = names.map((_,j)=> feed[j] + nofeed[j]);
    const props = names.map((_,j)=> feed[j] / totals[j]);

    const rows = [];
    const pList = [];

    for (let i=0;i<K;i++){
      for (let j=i+1;j<K;j++){
        const a = feed[i], b = nofeed[i], c = feed[j], d = nofeed[j];
        const fe = fisherExactTwoSided(a,b,c,d);
        pList.push(fe.p);

        rows.push({
          A: names[i], B: names[j],
          n_A: totals[i], n_B: totals[j],
          A_feed: a, A_no: b, B_feed: c, B_no: d,
          prop_A: props[i], prop_B: props[j],
          diff_prop: (props[i] - props[j]),
          odds_ratio: fe.OR,
          p_fisher: fe.p
        });
      }
    }

    const pHolm = holm1D(pList);
    rows.forEach((r, idx) => r.p_holm = pHolm[idx]);

    // ‚úÖ ahora: dos decisiones de significancia (p_fisher y p_holm)
    rows.forEach(r=>{
      r.sig_fisher = (r.p_fisher < alpha) ? "S√≠" : "No";
      r.sig_holm   = (r.p_holm   < alpha) ? "S√≠" : "No";
      r.tendencia  = (r.p_fisher < 0.10) ? "S√≠" : "No";
    });

    rows.sort((x,y)=> x.p_fisher - y.p_fisher);

    const pMat = Array.from({length:K}, ()=> Array(K).fill(1));
    rows.forEach(r=>{
      const i = names.indexOf(r.A);
      const j = names.indexOf(r.B);
      pMat[i][j] = r.p_fisher;
      pMat[j][i] = r.p_fisher;
    });

    // Potencia (aprox normal, bilateral)
    const powerRows = [];
    for (let i=0;i<K;i++){
      for (let j=i+1;j<K;j++){
        const p1 = props[i], p2 = props[j];
        const n1 = totals[i], n2 = totals[j];

        const se = Math.sqrt((p1*(1-p1))/n1 + (p2*(1-p2))/n2);
        const zAlpha = jStat.normal.inv(1 - alpha/2, 0, 1);

        const delta = Math.abs(p1 - p2);
        const zEff = (se > 0) ? (delta / se) : 0;

        const power = 1 - jStat.normal.cdf(zAlpha - zEff, 0, 1) + jStat.normal.cdf(-zAlpha - zEff, 0, 1);

        powerRows.push({
          A: names[i], B: names[j],
          prop_A: p1, prop_B: p2,
          diff_pp: (p1 - p2) * 100,
          power: clamp01(power)
        });
      }
    }
    powerRows.sort((x,y)=> y.power - y.power);

    return {rows, pMat, powerRows};
  }

  function renderPairsTable(rows, alpha){
    if (!rows.length) return '<div class="small-muted">No hay pares para comparar.</div>';

    const header = `
      <thead><tr>
        <th>A</th><th>B</th>
        <th>prop_A</th><th>prop_B</th><th>Œî pp</th>
        <th>Odds Ratio</th>
        <th>p_fisher</th>
        <th>Significativo p_fisher (Œ±=${alpha})</th>
        <th>p_holm</th>
        <th>Significativo p_holm (Œ±=${alpha})</th>
        <th>Tendencia p&lt;0.10</th>
      </tr></thead>`;

    const body = rows.map(r=>{
      const propA = `${(r.prop_A*100).toFixed(1)}% (${r.A_feed}/${r.n_A})`;
      const propB = `${(r.prop_B*100).toFixed(1)}% (${r.B_feed}/${r.n_B})`;
      const dpp = (r.diff_prop*100).toFixed(2);

      return `<tr>
        <td>${escapeHtml(r.A)}</td>
        <td>${escapeHtml(r.B)}</td>
        <td>${propA}</td>
        <td>${propB}</td>
        <td>${dpp}</td>
        <td>${fmt(r.odds_ratio,3)}</td>
        <td>${fmtP(r.p_fisher)}</td>
        <td><b>${r.sig_fisher}</b></td>
        <td>${fmtP(r.p_holm)}</td>
        <td><b>${r.sig_holm}</b></td>
        <td>${r.tendencia}</td>
      </tr>`;
    }).join('');

    return `<table class="table table-sm align-middle">${header}<tbody>${body}</tbody></table>`;
  }

  function renderPMatrix(names, pMat, alpha){
    const K = names.length;
    let html = '<table class="table table-sm align-middle">';
    html += '<thead><tr><th></th>' + names.map(n=>`<th>${escapeHtml(n)}</th>`).join('') + '</tr></thead>';
    html += '<tbody>';
    for (let i=0;i<K;i++){
      html += `<tr><th>${escapeHtml(names[i])}</th>`;
      for (let j=0;j<K;j++){
        const p = pMat[i][j];
        const star = (i!==j && p < alpha) ? ' <b>*</b>' : '';
        html += `<td>${fmt(p,4)}${star}</td>`;
      }
      html += '</tr>';
    }
    html += '</tbody></table>';
    return html;
  }

  function renderPowerTable(rows){
    if (!rows.length) return '<div class="small-muted">No hay potencia para calcular.</div>';

    const header = `
      <thead><tr>
        <th>A</th><th>B</th>
        <th>prop_A</th><th>prop_B</th>
        <th>Œî pp</th>
        <th>Potencia (aprox.)</th>
      </tr></thead>`;

    const body = rows.map(r=>{
      return `<tr>
        <td>${escapeHtml(r.A)}</td>
        <td>${escapeHtml(r.B)}</td>
        <td>${(r.prop_A*100).toFixed(1)}%</td>
        <td>${(r.prop_B*100).toFixed(1)}%</td>
        <td>${r.diff_pp.toFixed(1)}</td>
        <td><b>${r.power.toFixed(2)}</b></td>
      </tr>`;
    }).join('');

    return `<table class="table table-sm align-middle">${header}<tbody>${body}</tbody></table>`;
  }

  // =========================
  // Render tablas
  // =========================
  function renderExpected(names, E){
    let html = '<table class="table table-sm align-middle">';
    html += '<thead><tr><th>Fila</th>' + names.map(n=>`<th>${escapeHtml(n)}</th>`).join('') + '</tr></thead>';
    html += '<tbody>';
    html += '<tr><th>Alimentaci√≥n</th>' + E[0].map(x=>`<td>${fmt(x,2)}</td>`).join('') + '</tr>';
    html += '<tr><th>No_alimentaci√≥n</th>' + E[1].map(x=>`<td>${fmt(x,2)}</td>`).join('') + '</tr>';
    html += '</tbody></table>';
    return html;
  }

  function renderResiduals(names, Z, P, Pbonf, Pholm){
    const K = names.length;

    function rowHtml(label, i){
      let cells = '';
      for (let j=0;j<K;j++){
        cells += `
          <td>
            <div><span class="small-muted">z</span> ${fmt(Z[i][j],2)}</div>
            <div><span class="small-muted">p</span> ${fmt(P[i][j],3)}</div>
            <div><span class="small-muted">p_bonf</span> ${fmt(Pbonf[i][j],3)}</div>
            <div><span class="small-muted">p_holm</span> ${fmt(Pholm[i][j],3)}</div>
          </td>
        `;
      }
      return `<tr><th>${label}</th>${cells}</tr>`;
    }

    let html = '<table class="table table-sm align-middle">';
    html += '<thead><tr><th>Fila</th>' + names.map(n=>`<th>${escapeHtml(n)}</th>`).join('') + '</tr></thead>';
    html += '<tbody>';
    html += rowHtml('Alimentaci√≥n', 0);
    html += rowHtml('No_alimentaci√≥n', 1);
    html += '</tbody></table>';
    return html;
  }

  function renderGlobal({chi2, p, dof, V, pctBelow5, anyBelow1, fisher}){
    const warn1 = anyBelow1 ? pill('Esperado < 1: S√≠', 'bad') : pill('Esperado < 1: No', 'ok');
    const warn5 = (pctBelow5 > 20) ? pill(`Esperados < 5: ${pctBelow5.toFixed(1)}%`, 'warn') : pill(`Esperados < 5: ${pctBelow5.toFixed(1)}%`, 'ok');

    const labelP = (pv) => {
      if (!Number.isFinite(pv)) return 'No disponible.';
      if (pv < 0.001) return 'Diferencias MUY claras (casi seguro no es azar).';
      if (pv < 0.05)  return 'Hay diferencias (p < 0.05).';
      return 'No se detectan diferencias claras entre tratamientos.';
    };

    const labelV = (v) => {
      if (!Number.isFinite(v)) return 'No disponible.';
      if (v < 0.10) return 'Impacto peque√±o (cambio leve).';
      if (v < 0.30) return 'Impacto bajo a moderado.';
      if (v < 0.50) return 'Impacto moderado (relevante).';
      return 'Impacto grande (muy marcado).';
    };

    const labelExpected = () => {
      if (anyBelow1) return '‚ö†Ô∏è Hay celdas con esperado < 1: interpretar con cautela.';
      if (pctBelow5 > 20) return '‚ö†Ô∏è Muchos esperados < 5: interpretar con cautela.';
      return '‚úÖ Los supuestos del test se cumplen bien.';
    };

    return `
      <div class="d-flex flex-wrap gap-2 mb-2">${warn1} ${warn5}</div>
      <div class="small-muted mb-3">${labelExpected()}</div>

      <div class="row g-2">
        <div class="col-md-6">
          <div class="small-muted">Chi-cuadrado</div>
          <div class="h5 mb-0">œá¬≤(${dof}) = ${fmt(chi2,3)}</div>
          <div class="small-muted">M√°s grande = m√°s distinta la alimentaci√≥n entre tratamientos.</div>
        </div>

        <div class="col-md-6">
          <div class="small-muted">p-value (œá¬≤)</div>
          <div class="h5 mb-0">p = ${fmtP(p)}</div>
          <div class="small-muted">${labelP(p)}</div>
        </div>

        <div class="col-md-6 mt-2">
          <div class="small-muted">V de Cram√©r</div>
          <div class="h6 mb-0">${fmt(V,3)} <span class="small-muted">(‚âà0.1 peque√±o, 0.3 mediano, 0.5 grande)</span></div>
          <div class="small-muted">${labelV(V)}</div>
        </div>

        <div class="col-md-6 mt-2">
          <div class="small-muted">Fisher‚ÄìFreeman‚ÄìHalton (MC)</div>
          <div class="h6 mb-0">œá¬≤‚âà${fmt(fisher.chiObs,3)}, p‚âà${fmtP(fisher.p)}</div>
          <div class="small-muted">Confirmaci√≥n ‚Äúm√°s estricta‚Äù.</div>
        </div>
      </div>
    `;
  }

  function buildSummary(names, obs, Z, P, Pholm){
    const feed = obs[0];
    const totals = names.map((_,j)=> obs[0][j] + obs[1][j]);
    const props = names.map((_,j)=> feed[j] / totals[j]);

    const idx = props.map((v,i)=>({i,v})).sort((a,b)=>b.v-a.v).map(x=>x.i);

    return idx.map(j => ({
      tratamiento: names[j],
      prop_alim: props[j],
      z_alim: Z[0][j],
      p_alim: P[0][j],
      p_holm_alim: Pholm[0][j]
    }));
  }

  function renderProps(rows){
    const lines = rows.map(r => `
      <div class="d-flex justify-content-between gap-2">
        <div>${escapeHtml(r.tratamiento)}</div>
        <div><b>${(r.prop_alim*100).toFixed(1)}%</b></div>
      </div>
    `).join('');
    return `<div class="small-muted mb-2">Proporci√≥n de Alimentaci√≥n por tratamiento (ordenado desc.)</div>${lines}`;
  }

  function renderObs3K(names, raw3){
    let html = '<table class="table table-sm align-middle">';
    html += '<thead><tr><th>Estado</th>' + names.map(n=>`<th>${escapeHtml(n)}</th>`).join('') + '</tr></thead>';
    html += '<tbody>';
    html += '<tr><th>Alimentaci√≥n</th>' + raw3.feed.map(x=>`<td>${x}</td>`).join('') + '</tr>';
    html += '<tr><th>Excitaci√≥n</th>' + raw3.excit.map(x=>`<td>${x}</td>`).join('') + '</tr>';
    html += '<tr><th>Inm√≥vil</th>' + raw3.immob.map(x=>`<td>${x}</td>`).join('') + '</tr>';
    html += '</tbody></table>';
    return html;
  }

  // =========================
  // Charts
  // =========================
  let chart = null;       // barChart
  let behavChart = null;  // behavChart (100% apilado 3 estados, sumas temporales)
  let areaChartGlobal = null; // promedio global
  let areaCharts = [];    // por tratamiento

  function drawChart(summaryRows, fisherLine){
    const labels = summaryRows.map(r => r.tratamiento);
    const data = summaryRows.map(r => r.prop_alim);

    const ctx = document.getElementById('barChart');
    if (chart) chart.destroy();

    chart = new Chart(ctx, {
      type: 'bar',
      data: { labels, datasets: [{ label: 'Proporci√≥n de Alimentaci√≥n', data, borderWidth: 1 }] },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true, labels: { color: '#111827', font: { size: 13 } } },
          title: {
            display: true,
            text: ['Proporci√≥n de Alimentaci√≥n por Tratamiento', fisherLine],
            color: '#111827',
            font: { size: 14, weight: 'bold' },
            padding: { bottom: 10 }
          },
          tooltip: { callbacks: { label: (ctx) => ` ${(ctx.raw*100).toFixed(1)}%` } }
        },
        scales: {
          y: { beginAtZero: true, max: 1, ticks: { callback: (v) => `${Math.round(v*100)}%`, color: '#111827' }, grid: { color: '#d1d5db' } },
          x: { ticks: { color: '#111827', maxRotation: 20, minRotation: 20 }, grid: { display: false } }
        }
      }
    });
  }

  function drawBehaviorChartFrom3K(names, feed, excit, immob){
    const totals = names.map((_,j)=> safeInt(feed[j]) + safeInt(excit[j]) + safeInt(immob[j]));
    if (totals.some(t => t === 0)) throw new Error('Hay tratamientos con total 0 en 3√óK derivado.');

    const pA = names.map((_,j)=> safeInt(feed[j])  / totals[j]);
    const pE = names.map((_,j)=> safeInt(excit[j]) / totals[j]);
    const pI = names.map((_,j)=> safeInt(immob[j]) / totals[j]);

    const canvas = document.getElementById('behavChart');
    if (!canvas) return;

    if (behavChart) behavChart.destroy();

    behavChart = new Chart(canvas, {
      type: 'bar',
      data: {
        labels: names,
        datasets: [
          { label:'Alimentaci√≥n', data: pA, stack:'s1', borderWidth: 1 },
          { label:'Excitaci√≥n',   data: pE, stack:'s1', borderWidth: 1 },
          { label:'Inm√≥vil',      data: pI, stack:'s1', borderWidth: 1 },
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins:{
          title:{ display:true, text:'Distribuci√≥n de estados por tratamiento (100% apilado) ‚Äî suma temporal', color:'#111827', font:{size:14, weight:'bold'} },
          legend:{ labels:{ color:'#111827' } },
          tooltip:{ callbacks:{ label:(ctx)=>` ${ctx.dataset.label}: ${(ctx.raw*100).toFixed(1)}%` } }
        },
        scales:{
          x:{ stacked:true, ticks:{ color:'#111827', maxRotation:20, minRotation:20 }, grid:{ display:false } },
          y:{ stacked:true, min:0, max:1, ticks:{ callback:(v)=>`${Math.round(v*100)}%`, color:'#111827' }, grid:{ color:'#e5e7eb' } }
        }
      }
    });
  }

  function destroyAreaCharts(){
    areaCharts.forEach(ch => { try { ch.destroy(); } catch(e){} });
    areaCharts = [];
    const wrap = document.getElementById('areaChartsWrap');
    if (wrap) wrap.innerHTML = '';
  }

  // ‚úÖ Construye series temporales por tratamiento y tiempo => porcentajes (100% por tiempo)
  function buildSeriesFromTemporal(temporalData){
    // Map: treatment -> Map(time -> {a,e,i})
    const m = new Map();

    for (const r of temporalData){
      if (!r || !r.tratamiento) continue;
      const trt = String(r.tratamiento).trim();
      const st = normalizeEstado(r.estado);
      const t = Number(r.tiempo);
      const v = safeInt(r.valor);

      if (!Number.isFinite(t)) continue;
      if (!['alimentacion','excitacion','inmovil'].includes(st)) continue;

      if (!m.has(trt)) m.set(trt, new Map());
      const tm = m.get(trt);
      if (!tm.has(t)) tm.set(t, {alimentacion:0, excitacion:0, inmovil:0});
      tm.get(t)[st] += v;
    }

    // Convert to plain object: trt -> {times:[], pA:[], pE:[], pI:[]}
    const out = {};
    for (const [trt, tm] of m.entries()){
      const times = Array.from(tm.keys()).sort((a,b)=>a-b);
      const pA=[], pE=[], pI=[];
      for (const tt of times){
        const o = tm.get(tt);
        const tot = (o.alimentacion + o.excitacion + o.inmovil);
        if (tot <= 0) continue; // ignora tiempos sin total
        pA.push({x: tt, y: o.alimentacion / tot});
        pE.push({x: tt, y: o.excitacion / tot});
        pI.push({x: tt, y: o.inmovil / tot});
      }
      if (pA.length) out[trt] = {pA, pE, pI};
    }
    return out;
  }

  // ‚úÖ √Åreas apiladas (100%) por tratamiento
  function drawAreaChartsPercentByTreatment(seriesByTrt){
    const wrap = document.getElementById('areaChartsWrap');
    if (!wrap) return;

    destroyAreaCharts();

    const trts = Object.keys(seriesByTrt || {});
    if (!trts.length){
      wrap.innerHTML = `<div class="small-muted">No hay series temporales v√°lidas para graficar.</div>`;
      return;
    }

    trts.forEach((treatName, idx) => {
      const s = seriesByTrt[treatName];
      if (!s || !s.pA?.length) return;

      const card = document.createElement('div');
      card.className = 'chart-wrap';
      card.style.height = '280px';
      card.innerHTML = `<canvas id="areaChart_${idx}"></canvas>`;
      wrap.appendChild(card);

      const canvas = document.getElementById(`areaChart_${idx}`);

      const ch = new Chart(canvas, {
        type: 'line',
        data: {
          datasets: [
            { label:'Alimentaci√≥n', data: s.pA, fill:true, borderWidth:1, tension:0.25, stack:'s1' },
            { label:'Excitaci√≥n',   data: s.pE, fill:true, borderWidth:1, tension:0.25, stack:'s1' },
            { label:'Inm√≥vil',      data: s.pI, fill:true, borderWidth:1, tension:0.25, stack:'s1' },
          ]
        },
        options: {
          responsive:true,
          maintainAspectRatio:false,
          parsing:false,
          plugins:{
            title:{ display:true, text:`√Åreas apiladas (100% por tiempo) ‚Äî ${treatName}`, color:'#111827', font:{size:14, weight:'bold'} },
            legend:{ labels:{ color:'#111827' } },
            tooltip:{ callbacks:{ label:(ctx)=>` ${ctx.dataset.label}: ${(ctx.raw.y*100).toFixed(1)}%` } }
          },
          scales:{
            x:{ type:'linear', ticks:{ color:'#111827' }, grid:{ color:'#e5e7eb' }, title:{ display:true, text:'Tiempo', color:'#111827' } },
            y:{ stacked:true, min:0, max:1, ticks:{ callback:(v)=>`${Math.round(v*100)}%`, color:'#111827' }, grid:{ color:'#e5e7eb' }, title:{ display:true, text:'%', color:'#111827' } }
          },
          elements:{ point:{ radius:2 } }
        }
      });

      areaCharts.push(ch);
    });
  }

  // ‚úÖ Promedio global (100%) por tiempo: promedio simple de proporciones por tratamiento en cada tiempo
  function drawAreaChartGlobal(seriesByTrt){
    const canvas = document.getElementById('areaChartGlobal');
    if (!canvas) return;

    // juntar todos los tiempos
    const timeSet = new Set();
    for (const trt of Object.keys(seriesByTrt || {})){
      for (const p of seriesByTrt[trt].pA) timeSet.add(p.x);
    }
    const times = Array.from(timeSet).sort((a,b)=>a-b);
    if (!times.length){
      if (areaChartGlobal) areaChartGlobal.destroy();
      areaChartGlobal = null;
      return;
    }

    const pA=[], pE=[], pI=[];
    for (const tt of times){
      let sA=0, sE=0, sI=0, n=0;
      for (const trt of Object.keys(seriesByTrt)){
        const s = seriesByTrt[trt];
        const a = s.pA.find(z=>z.x===tt)?.y;
        const e = s.pE.find(z=>z.x===tt)?.y;
        const i = s.pI.find(z=>z.x===tt)?.y;
        if ([a,e,i].some(v=>!Number.isFinite(v))) continue;
        sA += a; sE += e; sI += i; n++;
      }
      if (!n) continue;
      pA.push({x: tt, y: sA/n});
      pE.push({x: tt, y: sE/n});
      pI.push({x: tt, y: sI/n});
    }

    if (areaChartGlobal) areaChartGlobal.destroy();
    areaChartGlobal = new Chart(canvas, {
      type:'line',
      data:{ datasets:[
        { label:'Alimentaci√≥n', data:pA, fill:true, borderWidth:1, tension:0.25, stack:'s1' },
        { label:'Excitaci√≥n',   data:pE, fill:true, borderWidth:1, tension:0.25, stack:'s1' },
        { label:'Inm√≥vil',      data:pI, fill:true, borderWidth:1, tension:0.25, stack:'s1' },
      ]},
      options:{
        responsive:true,
        maintainAspectRatio:false,
        parsing:false,
        plugins:{
          title:{ display:true, text:'√Åreas apiladas (100% por tiempo) ‚Äî promedio global', color:'#111827', font:{size:14, weight:'bold'} },
          legend:{ labels:{ color:'#111827' } },
          tooltip:{ callbacks:{ label:(ctx)=>` ${ctx.dataset.label}: ${(ctx.raw.y*100).toFixed(1)}%` } }
        },
        scales:{
          x:{ type:'linear', ticks:{ color:'#111827' }, grid:{ color:'#e5e7eb' }, title:{ display:true, text:'Tiempo', color:'#111827' } },
          y:{ stacked:true, min:0, max:1, ticks:{ callback:(v)=>`${Math.round(v*100)}%`, color:'#111827' }, grid:{ color:'#e5e7eb' }, title:{ display:true, text:'%', color:'#111827' } }
        },
        elements:{ point:{ radius:2 } }
      }
    });
  }

  // =========================
  // 3√óK derivado desde temporalData
  // =========================
  function build3xKFromTemporal(temporalData){
    const treatments = [...new Set(temporalData.map(d => String(d.tratamiento || '').trim()).filter(Boolean))];

    const feed  = [];
    const excit = [];
    const immob = [];

    treatments.forEach(trt => {
      const rows = temporalData.filter(d => String(d.tratamiento || '').trim() === trt);
      feed.push(sum(rows.filter(d => normalizeEstado(d.estado) === 'alimentacion').map(d => safeInt(d.valor))));
      excit.push(sum(rows.filter(d => normalizeEstado(d.estado) === 'excitacion').map(d => safeInt(d.valor))));
      immob.push(sum(rows.filter(d => normalizeEstado(d.estado) === 'inmovil').map(d => safeInt(d.valor))));
    });

    return { names: treatments, raw3: { feed, excit, immob } };
  }

  // =========================
  // Downloads
  // =========================
  let lastSummaryRows = null;

  function downloadCSV(rows){
    const header = ['tratamiento','prop_alim','z_alim','p_alim','p_holm_alim'];
    const csv = [header.join(',')].concat(
      rows.map(r => {
        const vals = [
          `"${String(r.tratamiento).replaceAll('"','""')}"`,
          r.prop_alim,
          r.z_alim,
          r.p_alim,
          r.p_holm_alim
        ];
        return vals.join(',');
      })
    ).join('\n');

    const blob = new Blob([csv], {type: 'text/csv;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'resumen_alimentacion.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // =========================
  // Upload Excel/CSV
  // - Formato temporal (tratamiento, estado, tiempo, valor)
  // - Legacy 3√óK (estado + tratamientos) -> se convierte a temporal tiempo=0
  // =========================
  function setTemporalDataFrom3xK(names, feed, excit, immob){
    // convierte 3√óK a temporal con tiempo=0
    temporalData = [];
    names.forEach((trt, j)=>{
      temporalData.push({tratamiento: trt, estado: 'alimentacion', tiempo: 0, valor: safeInt(feed[j])});
      temporalData.push({tratamiento: trt, estado: 'excitacion', tiempo: 0, valor: safeInt(excit[j])});
      temporalData.push({tratamiento: trt, estado: 'inmovil', tiempo: 0, valor: safeInt(immob[j])});
    });
  }

  async function loadExcelFile(file){
    const ext = file.name.toLowerCase().split('.').pop();

    // CSV
    if (ext === 'csv'){
      const text = await file.text();
      const lines = text.split(/\r?\n/).filter(l=>l.trim().length);

      const commaCount = (lines[0].match(/,/g) || []).length;
      const semiCount  = (lines[0].match(/;/g) || []).length;
      const delim = semiCount > commaCount ? ';' : ',';

      const header = lines[0].split(delim).map(x=>x.trim());
      const lower = header.map(h=>h.toLowerCase().trim());

      const idxTrat = lower.indexOf('tratamiento');
      const idxEst  = lower.indexOf('estado');
      const idxTime = lower.indexOf('tiempo');
      const idxVal  = lower.indexOf('valor');

      // Formato temporal largo
      if (idxTrat>=0 && idxEst>=0 && idxTime>=0 && idxVal>=0){
        temporalData = [];
        for (let i=1;i<lines.length;i++){
          const parts = lines[i].split(delim).map(x=>x.trim());
          temporalData.push({
            tratamiento: parts[idxTrat],
            estado: normalizeEstado(parts[idxEst]),
            tiempo: Number(parts[idxTime]),
            valor: safeInt(parts[idxVal])
          });
        }
        return;
      }

      // Legacy 3√óK
      const names = header.slice(1);
      const map = {alimentacion: [], excitacion: [], inmovil: []};

      for (let i=1;i<lines.length;i++){
        const parts = lines[i].split(delim).map(x=>x.trim());
        const estado = normalizeEstado(parts[0]);
        const vals = parts.slice(1).map(v => safeInt(v));
        if (map[estado]) map[estado] = vals;
      }

      if (!map.alimentacion.length || !map.excitacion.length || !map.inmovil.length){
        throw new Error('CSV: usa formato temporal (tratamiento, estado, tiempo, valor) o legacy 3√óK (estado + tratamientos).');
      }

      setTemporalDataFrom3xK(names, map.alimentacion, map.excitacion, map.inmovil);
      return;
    }

    // Excel xlsx/xls
    const buf = await file.arrayBuffer();
    const wb = XLSX.read(buf, {type:'array'});
    const ws = wb.Sheets[wb.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(ws, {defval: ''});
    if (!rows.length) throw new Error('El archivo est√° vac√≠o.');

    const cols = Object.keys(rows[0] || {});
    const lowerCols = cols.map(c=>String(c).toLowerCase().trim());

    // Temporal largo
    const cTrat = cols[lowerCols.indexOf('tratamiento')];
    const cEst  = cols[lowerCols.indexOf('estado')];
    const cTime = cols[lowerCols.indexOf('tiempo')];
    const cVal  = cols[lowerCols.indexOf('valor')];

    if (cTrat && cEst && cTime && cVal){
      temporalData = rows.map(r => ({
        tratamiento: String(r[cTrat]).trim(),
        estado: normalizeEstado(r[cEst]),
        tiempo: Number(r[cTime]),
        valor: safeInt(r[cVal])
      }));
      return;
    }

    // Legacy 3√óK
    const estadoCol = cols.find(c => String(c).toLowerCase().trim() === 'estado');
    if (!estadoCol) throw new Error('Excel: usa formato temporal (tratamiento, estado, tiempo, valor) o legacy 3√óK con columna "estado".');

    const names = cols.filter(c => c !== estadoCol);
    const map = {alimentacion: [], excitacion: [], inmovil: []};

    for (const r of rows){
      const estado = normalizeEstado(r[estadoCol]);
      const vals = names.map(n => safeInt(r[n]));
      if (map[estado]) map[estado] = vals;
    }

    if (!map.alimentacion.length || !map.excitacion.length || !map.inmovil.length){
      throw new Error('Legacy 3√óK: faltan filas alimentaci√≥n/excitaci√≥n/inmovil.');
    }

    setTemporalDataFrom3xK(names, map.alimentacion, map.excitacion, map.inmovil);
  }

  // =========================
  // Ejemplo: serie temporal que suma EXACTO a 3√óK
  // (3 tiempos: 0, 10, 20; las sumas coinciden)
  // =========================
  function loadExample(){
    const names = [
      'Control KAT ES',
      'T1 Katal ES + premix ajo 10 kg/tm',
      'T2 Katal ES + Premix ajo china 10 kg/tm',
      'T3 Katal ES + 2 Kg/tm Citoprac'
    ];

    const totals = {
      // [alim, excit, immob] totales (suma temporal)
      [names[0]]: [14,45,21],
      [names[1]]: [13,45,22],
      [names[2]]: [35,27,18],
      [names[3]]: [ 5,40,35],
    };

    // split en 3 tiempos (0,10,20) que suma exacto
    // (puedes cambiar estos splits; solo aseg√∫rate que sumen)
    const splits = {
      0:  [0.40, 0.30, 0.30],
      10: [0.30, 0.40, 0.30],
      20: [0.30, 0.30, 0.40],
    };

    temporalData = [];
    for (const trt of names){
      const [A,E,I] = totals[trt];
      const times = [0,10,20];

      // para que sea exacto entero: repartimos con ‚Äúrestos‚Äù
      function splitInt(total){
        const parts = times.map(t => Math.floor(total * splits[t][0])); // base
        let used = sum(parts);
        let rem = total - used;
        // distribuir rem
        for (let k=0; k<times.length && rem>0; k++){ parts[k]++; rem--; }
        return parts;
      }

      // Vamos a hacer un split simple por estado con reglas fijas (exactas):
      // A: [ceil, floor, resto], E: [floor, ceil, resto], I: [resto, floor, ceil] (para variar)
      const A0 = Math.floor(A*0.4), A10 = Math.floor(A*0.3), A20 = A - A0 - A10;
      const E0 = Math.floor(E*0.3), E10 = Math.floor(E*0.4), E20 = E - E0 - E10;
      const I0 = Math.floor(I*0.3), I10 = Math.floor(I*0.3), I20 = I - I0 - I10;

      const perTime = {
        0:  {alimentacion:A0,  excitacion:E0,  inmovil:I0},
        10: {alimentacion:A10, excitacion:E10, inmovil:I10},
        20: {alimentacion:A20, excitacion:E20, inmovil:I20},
      };

      for (const t of [0,10,20]){
        temporalData.push({tratamiento: trt, estado:'alimentacion', tiempo:t, valor: perTime[t].alimentacion});
        temporalData.push({tratamiento: trt, estado:'excitacion',   tiempo:t, valor: perTime[t].excitacion});
        temporalData.push({tratamiento: trt, estado:'inmovil',      tiempo:t, valor: perTime[t].inmovil});
      }
    }
  }

  // =========================
  // Ejecutar an√°lisis (fuente √∫nica: temporalData)
  // =========================
  async function run(){
    try {
      if (!temporalData.length) throw new Error('No hay datos. Carga un Excel/CSV o presiona "Cargar ejemplo".');

      const alpha = Math.min(0.50, Math.max(0.001, Number(document.getElementById('alpha').value) || 0.05));

      // 1) 3√óK derivado
      const {names, raw3} = build3xKFromTemporal(temporalData);
      if (names.length < 2) throw new Error('Necesitas al menos 2 tratamientos en la serie temporal.');

      // Validaci√≥n: ning√∫n tratamiento con total 0 (sumas temporales)
      const totals3 = names.map((_,j)=> raw3.feed[j] + raw3.excit[j] + raw3.immob[j]);
      if (totals3.some(t => t === 0)) throw new Error('Hay tratamientos con total 0 en 3√óK derivado.');

      document.getElementById('obs3kWrap').innerHTML = renderObs3K(names, raw3);

      // 2) Colapsar 3->2 para an√°lisis
      const nofeed = raw3.excit.map((v,i)=> v + raw3.immob[i]);
      const obs = [raw3.feed, nofeed];
      const N = sum(obs[0]) + sum(obs[1]);
      if (N === 0) throw new Error('La tabla derivada est√° vac√≠a (N=0).');

      // 3) Chi2
      const {chi2, p, dof, E, V} = chiSquare2xK(obs);

      const flatE = [...E[0], ...E[1]];
      const pctBelow5 = flatE.filter(x => x < 5).length / flatE.length * 100;
      const anyBelow1 = flatE.some(x => x < 1);

      const Z = stdResiduals(obs, E);
      const P = pvalsFromZ(Z);
      const Pbonf = bonferroni(P);
      const Pholm = holm(P);

      const nSim = Math.max(1000, safeInt(document.getElementById('nSim').value));
      const seed = safeInt(document.getElementById('seed').value);
      const fisher = fisherMC2xK(obs, nSim, seed);

      document.getElementById('globalOut').innerHTML = renderGlobal({chi2, p, dof, V, pctBelow5, anyBelow1, fisher});
      document.getElementById('expectedWrap').innerHTML = renderExpected(names, E);
      document.getElementById('residWrap').innerHTML = renderResiduals(names, Z, P, Pbonf, Pholm);

      const summaryRows = buildSummary(names, obs, Z, P, Pholm);
      lastSummaryRows = summaryRows;

      document.getElementById('propOut').innerHTML = renderProps(summaryRows);

      // Gr√°fico barras: proporci√≥n alimentaci√≥n
      drawChart(summaryRows, `Fisher‚ÄìFreeman‚ÄìHalton (MC): œá¬≤‚âà${fmt(fisher.chiObs,3)}, p‚âà${fmtP(fisher.p)}`);

      // Gr√°fico 100% apilado por suma temporal (3√óK)
      drawBehaviorChartFrom3K(names, raw3.feed, raw3.excit, raw3.immob);

      // ‚úÖ √Åreas apiladas (100% por tiempo)
      const seriesByTrt = buildSeriesFromTemporal(temporalData);
      drawAreaChartsPercentByTreatment(seriesByTrt);
      drawAreaChartGlobal(seriesByTrt);

      // Pares y potencia
      const pairs = pairwiseComparisons(names, obs, alpha);
      document.getElementById('pairsWrap').innerHTML = renderPairsTable(pairs.rows, alpha);
      document.getElementById('pMatWrap').innerHTML  = renderPMatrix(names, pairs.pMat, alpha);
      document.getElementById('powerWrap').innerHTML = renderPowerTable(pairs.powerRows);

    } catch (err){
      alert(err?.message ?? String(err));
      console.error(err);
    }
  }

  // =========================
  // Limpiar
  // =========================
  function clearAll(){
    temporalData = [];

    document.getElementById('obs3kWrap').innerHTML = '';
    document.getElementById('globalOut').innerHTML = '';
    document.getElementById('expectedWrap').innerHTML = '';
    document.getElementById('residWrap').innerHTML = '';
    document.getElementById('propOut').innerHTML = '';
    document.getElementById('pairsWrap').innerHTML = '';
    document.getElementById('pMatWrap').innerHTML = '';
    document.getElementById('powerWrap').innerHTML = '';
    lastSummaryRows = null;

    if (chart){ chart.destroy(); chart = null; }
    if (behavChart){ behavChart.destroy(); behavChart = null; }
    if (areaChartGlobal){ areaChartGlobal.destroy(); areaChartGlobal = null; }
    destroyAreaCharts();
  }

  // =========================
  // Eventos
  // =========================
  document.getElementById('btnClear').addEventListener('click', () => { clearAll(); });

  document.getElementById('btnExample').addEventListener('click', () => {
    loadExample();
    run();
  });

  document.getElementById('btnRun').addEventListener('click', run);

  document.getElementById('btnDownloadCSV').addEventListener('click', () => {
    if (!lastSummaryRows) return alert('Primero presiona Calcular.');
    downloadCSV(lastSummaryRows);
  });

  document.getElementById('fileExcel').addEventListener('change', async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    try{
      await loadExcelFile(f);
      await run();
    }catch(err){
      alert(err?.message ?? String(err));
      console.error(err);
    }finally{
      e.target.value = '';
    }
  });

  // init
  loadExample();
  run();
</script>

<!-- Bootstrap JS (necesario para tabs) -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
