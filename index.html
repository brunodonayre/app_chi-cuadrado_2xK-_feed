<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>App 2×K: Alimentación vs No-alimentación</title>

  <!-- Bootstrap (solo UI) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- jStat: Normal/Chi-square CDF, inv, etc. -->
  <script src="https://cdn.jsdelivr.net/npm/jstat@1.9.6/dist/jstat.min.js"></script>

  <!-- Chart.js para gráfico -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <style>
    body { background: #0b1220; }
    .card { border: 0; border-radius: 16px; }
    .card, .table { background: #0f172a; color: #e5e7eb; }
    .form-control, .form-select { background: #0b1220; color: #e5e7eb; border-color: #243146; }
    .form-control:focus, .form-select:focus { box-shadow: none; border-color: #3b82f6; }
    .btn-primary { border-radius: 12px; }
    .btn-outline-light, .btn-outline-danger { border-radius: 12px; }
    .table thead th { color: #cbd5e1; }
    .small-muted { color: #94a3b8; }
    .pill { display:inline-block; padding:.15rem .5rem; border-radius:999px; font-size:.8rem; }
    .pill-ok { background:#064e3b; color:#a7f3d0; }
    .pill-warn { background:#7c2d12; color:#fed7aa; }
    .pill-bad { background:#7f1d1d; color:#fecaca; }
    code { color:#93c5fd; }
  </style>
</head>

<body>
<div class="container py-4">
  <div class="row g-3">
    <div class="col-12">
      <div class="card p-4">
        <div class="d-flex flex-wrap gap-2 align-items-center justify-content-between">
          <div>
            <h1 class="h4 mb-1">App 2×K: Alimentación vs No-alimentación</h1>
            <div class="small-muted">
              Ingresa conteos por tratamiento. Calcula χ², V de Cramér, residuos z, correcciones (Bonferroni/Holm),
              Fisher–Freeman–Halton (Monte Carlo), comparaciones por pares (Fisher 2×2), matriz p-values y potencia estimada.
            </div>
          </div>
          <div class="d-flex gap-2">
            <button class="btn btn-outline-light" id="btnExample">Cargar ejemplo</button>
            <button class="btn btn-outline-light" id="btnClear">Limpiar</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Entrada -->
    <div class="col-12">
      <div class="card p-4">
        <div class="d-flex flex-wrap gap-2 align-items-center justify-content-between mb-3">
          <h2 class="h6 mb-0">1) Tabla observada</h2>
          <div class="d-flex gap-2">
            <button class="btn btn-outline-light" id="btnAddCol">+ Tratamiento</button>
            <button class="btn btn-outline-danger" id="btnRemoveCol">- Último</button>
          </div>
        </div>

        <div class="table-responsive">
          <table class="table table-sm align-middle" id="obsTable">
            <thead>
              <tr id="headRow">
                <th style="min-width:200px">Fila</th>
              </tr>
            </thead>
            <tbody>
              <tr id="rowFeed">
                <th>Alimentación</th>
              </tr>
              <tr id="rowNoFeed">
                <th>No_alimentación</th>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="row g-3 mt-1">
          <div class="col-md-3">
            <label class="form-label">Simulaciones Fisher MC</label>
            <input class="form-control" id="nSim" type="number" min="1000" step="1000" value="100000" />
            <div class="small-muted">Más simulaciones = p más estable (pero más lento).</div>
          </div>
          <div class="col-md-3">
            <label class="form-label">Semilla</label>
            <input class="form-control" id="seed" type="number" step="1" value="123" />
            <div class="small-muted">Cambia la semilla si quieres otra corrida reproducible.</div>
          </div>
          <div class="col-md-3">
            <label class="form-label">Nivel de significancia (α)</label>
            <input class="form-control" id="alpha" type="number" min="0.001" max="0.50" step="0.01" value="0.05" />
            <div class="small-muted">Usual: 0.05 (5%), opcional: 0.10 o 0.15.</div>
          </div>
          <div class="col-md-3 d-flex align-items-end">
            <button class="btn btn-primary w-100" id="btnRun">Calcular</button>
          </div>
        </div>

        <div class="small-muted mt-3">
          Nota: si hay esperados &lt; 1 o demasiados &lt; 5, interpreta con cautela.
        </div>
      </div>
    </div>

    <!-- Resultados -->
    <div class="col-12 col-lg-6">
      <div class="card p-4 h-100">
        <h2 class="h6">2) Resultados globales</h2>
        <div id="globalOut" class="mt-2"></div>
        <hr class="border-secondary" />
        <h2 class="h6">3) Esperados (E)</h2>
        <div class="table-responsive" id="expectedWrap"></div>
      </div>
    </div>

    <div class="col-12 col-lg-6">
      <div class="card p-4 h-100">
        <h2 class="h6">4) Proporción de Alimentación y gráfico</h2>
        <div id="propOut" class="mt-2"></div>
        <div class="mt-3">
          <canvas id="barChart" height="160"></canvas>
        </div>
        <div class="d-flex gap-2 mt-3">
          <button class="btn btn-outline-light" id="btnDownloadCSV">Descargar resumen CSV</button>
        </div>
      </div>
    </div>

    <div class="col-12">
      <div class="card p-4">
        <h2 class="h6">5) Residuos z y p-values por celda</h2>
        <div class="table-responsive" id="residWrap"></div>
        <div class="small-muted mt-2">Regla orientativa: |z| &gt; 1.96 ≈ p &lt; 0.05 (sin corrección).</div>
      </div>
    </div>

    <!-- NUEVO -->
    <div class="col-12">
      <div class="card p-4">
        <h2 class="h6">6) Comparaciones por pares (Fisher 2×2) + ajuste Holm</h2>
        <div class="small-muted mb-2">
          Compara cada par de tratamientos A vs B. p_fisher (sin ajustar) y p_holm (ajustado).
        </div>
        <div class="table-responsive" id="pairsWrap"></div>
      </div>
    </div>

    <div class="col-12">
      <div class="card p-4">
        <h2 class="h6">7) Matriz de p-values (Fisher 2×2, sin ajustar)</h2>
        <div class="small-muted mb-2">
          * indica p &lt; α (según el α ingresado arriba).
        </div>
        <div class="table-responsive" id="pMatWrap"></div>
      </div>
    </div>

    <div class="col-12">
      <div class="card p-4">
        <h2 class="h6">8) Potencia estimada por comparación (aprox.)</h2>
        <div class="small-muted mb-2">
          Estimación aproximada (normal) usando diferencia de proporciones y n observados.
        </div>
        <div class="table-responsive" id="powerWrap"></div>
      </div>
    </div>

  </div>
</div>

<script>
  // =========================
  // Utilidades
  // =========================
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const fmt = (x, d=4) => (Number.isFinite(x) ? x.toFixed(d) : 'NA');
  const fmtP = (p) => (Number.isFinite(p) ? (p < 0.0001 ? '<0.0001' : p.toFixed(4)) : 'NA');
  const sum = (arr) => arr.reduce((a,b)=>a+b,0);

  function pill(text, kind){
    const cls = kind === 'ok' ? 'pill-ok' : kind === 'warn' ? 'pill-warn' : 'pill-bad';
    return `<span class="pill ${cls}">${text}</span>`;
  }

  function safeInt(v){
    const n = Number(v);
    if (!Number.isFinite(n) || n < 0) return 0;
    return Math.floor(n);
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  // =========================
  // RNG + Hypergeom (para Fisher MC)
  // =========================
  function makeRng(seed){
    let x = (seed >>> 0) || 123456789;
    return function(){
      x ^= x << 13; x >>>= 0;
      x ^= x >> 17; x >>>= 0;
      x ^= x << 5;  x >>>= 0;
      return (x >>> 0) / 4294967296;
    }
  }

  function logFactorial(n){
    if (n < 2) return 0;
    return n*Math.log(n) - n + 0.5*Math.log(2*Math.PI*n) + 1/(12*n) - 1/(360*n*n*n);
  }

  function logChoose(n,k){
    if (k < 0 || k > n) return -Infinity;
    return logFactorial(n) - logFactorial(k) - logFactorial(n-k);
  }

  function hypergeomPmf(x, K, N, n){
    if (x < 0 || x > K || x > n || n-x > (N-K)) return 0;
    const logp = logChoose(K,x) + logChoose(N-K, n-x) - logChoose(N,n);
    return Math.exp(logp);
  }

  function hypergeomSample(rng, K, N, n){
    const xmin = Math.max(0, n - (N - K));
    const xmax = Math.min(n, K);
    let u = rng();
    let c = 0;
    for (let x = xmin; x <= xmax; x++){
      c += hypergeomPmf(x, K, N, n);
      if (u <= c) return x;
    }
    return xmax;
  }

  // =========================
  // Cálculos 2×K
  // =========================
  function chiSquare2xK(obs2xK){
    const K = obs2xK[0].length;
    const rowTotals = [sum(obs2xK[0]), sum(obs2xK[1])];
    const colTotals = Array.from({length: K}, (_,j)=> obs2xK[0][j] + obs2xK[1][j]);
    const N = rowTotals[0] + rowTotals[1];

    const E = [[],[]];
    for (let j=0;j<K;j++){
      E[0][j] = rowTotals[0] * colTotals[j] / N;
      E[1][j] = rowTotals[1] * colTotals[j] / N;
    }

    let chi2 = 0;
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++){
        const e = E[i][j];
        if (e > 0) chi2 += (obs2xK[i][j]-e)*(obs2xK[i][j]-e)/e;
      }
    }

    const dof = (2-1)*(K-1);
    const p = 1 - jStat.chisquare.cdf(chi2, dof);

    const denom = Math.min(2-1, K-1);
    const V = denom > 0 ? Math.sqrt(chi2 / (N * denom)) : NaN;

    return {chi2, p, dof, E, N, V};
  }

  function stdResiduals(obs, E){
    const K = obs[0].length;
    const Z = [[],[]];
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++){
        Z[i][j] = (obs[i][j] - E[i][j]) / Math.sqrt(E[i][j]);
      }
    }
    return Z;
  }

  function pvalsFromZ(Z){
    const K = Z[0].length;
    const P = [[],[]];
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++){
        const z = Math.abs(Z[i][j]);
        P[i][j] = 2*(1 - jStat.normal.cdf(z, 0, 1));
      }
    }
    return P;
  }

  function bonferroni(P){
    const K = P[0].length;
    const m = 2*K;
    const out = [[],[]];
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++) out[i][j] = clamp01(P[i][j]*m);
    }
    return out;
  }

  function holm(P){
    const K = P[0].length;
    const m = 2*K;
    const flat = [];
    for (let i=0;i<2;i++) for (let j=0;j<K;j++) flat.push({i,j,p:P[i][j]});
    flat.sort((a,b)=>a.p-b.p);

    let runningMax = 0;
    for (let k=0;k<m;k++){
      const t = k+1;
      const adj = (m - t + 1) * flat[k].p;
      runningMax = Math.max(runningMax, adj);
      flat[k].adj = clamp01(runningMax);
    }

    const out = [Array(K).fill(0), Array(K).fill(0)];
    for (const el of flat){ out[el.i][el.j] = el.adj; }
    return out;
  }

  function fisherMC2xK(obs2xK, nSim=100000, seed=123){
    const K = obs2xK[0].length;
    const colTotals = Array.from({length: K}, (_,j)=> obs2xK[0][j] + obs2xK[1][j]);
    const row1Tot = sum(obs2xK[0]);

    const {chi2: chiObs} = chiSquare2xK(obs2xK);

    const rng = makeRng(seed);
    let countGE = 0;

    for (let s=0; s<nSim; s++){
      let remainingSuccess = row1Tot;
      const remainingCol = colTotals.slice();
      const alloc = new Array(K).fill(0);

      for (let j=0; j<K-1; j++){
        const N = sum(remainingCol);
        const Kgood = remainingCol[j];
        const n = remainingSuccess;
        const x = hypergeomSample(rng, Kgood, N, n);
        alloc[j] = x;
        remainingSuccess -= x;
        remainingCol[j] = 0;
      }
      alloc[K-1] = remainingSuccess;

      const sim = [alloc, colTotals.map((ct,j)=>ct-alloc[j])];
      const {chi2: chiSim} = chiSquare2xK(sim);
      if (chiSim >= chiObs) countGE++;
    }

    return {chiObs, p: countGE / nSim};
  }

  // =========================
  // NUEVO: Fisher exacto 2×2 dos colas + OR
  // =========================
  function fisherExactTwoSided(a,b,c,d){
    const r1 = a + b, r2 = c + d;
    const c1 = a + c, c2 = b + d;
    const n  = r1 + r2;

    // OR con corrección 0.5 (evita división por cero)
    const OR = ((a+0.5)*(d+0.5))/((b+0.5)*(c+0.5));

    const amin = Math.max(0, r1 - c2);
    const amax = Math.min(r1, c1);

    function logHyp(a0){
      return logChoose(c1, a0) + logChoose(c2, r1-a0) - logChoose(n, r1);
    }

    const pObs = Math.exp(logHyp(a));
    let pTwo = 0;
    for (let x=amin; x<=amax; x++){
      const px = Math.exp(logHyp(x));
      if (px <= pObs + 1e-12) pTwo += px;
    }
    return {OR, p: clamp01(pTwo)};
  }

  function holm1D(pvals){
    const m = pvals.length;
    const order = [...pvals.keys()].sort((i,j)=>pvals[i]-pvals[j]);
    let runningMax = 0;
    const adj = new Array(m).fill(1);
    for (let k=0;k<m;k++){
      const i = order[k];
      const factor = (m - k);
      runningMax = Math.max(runningMax, pvals[i]*factor);
      adj[i] = clamp01(runningMax);
    }
    return adj;
  }

  function pairwiseComparisons(names, obs, alpha){
    const K = names.length;
    const feed = obs[0], nofeed = obs[1];
    const totals = names.map((_,j)=> feed[j] + nofeed[j]);
    const props = names.map((_,j)=> feed[j] / totals[j]);

    const rows = [];
    const pList = [];

    for (let i=0;i<K;i++){
      for (let j=i+1;j<K;j++){
        const a = feed[i], b = nofeed[i], c = feed[j], d = nofeed[j];
        const fe = fisherExactTwoSided(a,b,c,d);
        pList.push(fe.p);

        rows.push({
          A: names[i], B: names[j],
          n_A: totals[i], n_B: totals[j],
          A_feed: a, A_no: b, B_feed: c, B_no: d,
          prop_A: props[i], prop_B: props[j],
          diff_prop: (props[i] - props[j]),
          odds_ratio: fe.OR,
          p_fisher: fe.p
        });
      }
    }

    const pHolm = holm1D(pList);
    rows.forEach((r, idx) => r.p_holm = pHolm[idx]);
    rows.forEach(r=>{
      r.significativo = (r.p_holm < alpha) ? "Sí" : "No";
      r.tendencia = (r.p_fisher < 0.10) ? "Sí" : "No";
    });

    rows.sort((x,y)=> x.p_fisher - y.p_fisher);

    const pMat = Array.from({length:K}, ()=> Array(K).fill(1));
    rows.forEach(r=>{
      const i = names.indexOf(r.A);
      const j = names.indexOf(r.B);
      pMat[i][j] = r.p_fisher;
      pMat[j][i] = r.p_fisher;
    });

    // Potencia (aprox normal, bilateral)
    const powerRows = [];
    for (let i=0;i<K;i++){
      for (let j=i+1;j<K;j++){
        const p1 = props[i], p2 = props[j];
        const n1 = totals[i], n2 = totals[j];

        const se = Math.sqrt((p1*(1-p1))/n1 + (p2*(1-p2))/n2);
        const zAlpha = jStat.normal.inv(1 - alpha/2, 0, 1);

        const delta = Math.abs(p1 - p2);
        const zEff = (se > 0) ? (delta / se) : 0;

        const power = 1 - jStat.normal.cdf(zAlpha - zEff, 0, 1) + jStat.normal.cdf(-zAlpha - zEff, 0, 1);

        powerRows.push({
          A: names[i], B: names[j],
          prop_A: p1, prop_B: p2,
          diff_pp: (p1 - p2) * 100,
          power: clamp01(power)
        });
      }
    }
    powerRows.sort((x,y)=> y.power - x.power);

    return {rows, pMat, powerRows};
  }

  function renderPairsTable(rows, alpha){
    if (!rows.length) return '<div class="small-muted">No hay pares para comparar.</div>';

    const header = `
      <thead><tr>
        <th>A</th><th>B</th>
        <th>prop_A</th><th>prop_B</th><th>Δ pp</th>
        <th>Odds Ratio</th>
        <th>p_fisher</th><th>p_holm</th>
        <th>Significativo (α=${alpha})</th>
        <th>Tendencia p&lt;0.10</th>
      </tr></thead>`;

    const body = rows.map(r=>{
      const propA = `${(r.prop_A*100).toFixed(1)}% (${r.A_feed}/${r.n_A})`;
      const propB = `${(r.prop_B*100).toFixed(1)}% (${r.B_feed}/${r.n_B})`;
      const dpp = (r.diff_prop*100).toFixed(2);

      return `<tr>
        <td>${escapeHtml(r.A)}</td>
        <td>${escapeHtml(r.B)}</td>
        <td>${propA}</td>
        <td>${propB}</td>
        <td>${dpp}</td>
        <td>${fmt(r.odds_ratio,3)}</td>
        <td>${fmtP(r.p_fisher)}</td>
        <td>${fmtP(r.p_holm)}</td>
        <td><b>${r.significativo}</b></td>
        <td>${r.tendencia}</td>
      </tr>`;
    }).join('');

    return `<table class="table table-sm align-middle">${header}<tbody>${body}</tbody></table>`;
  }

  function renderPMatrix(names, pMat, alpha){
    const K = names.length;
    let html = '<table class="table table-sm align-middle">';
    html += '<thead><tr><th></th>' + names.map(n=>`<th>${escapeHtml(n)}</th>`).join('') + '</tr></thead>';
    html += '<tbody>';
    for (let i=0;i<K;i++){
      html += `<tr><th>${escapeHtml(names[i])}</th>`;
      for (let j=0;j<K;j++){
        const p = pMat[i][j];
        const star = (i!==j && p < alpha) ? ' <b>*</b>' : '';
        html += `<td>${fmt(p,4)}${star}</td>`;
      }
      html += '</tr>';
    }
    html += '</tbody></table>';
    return html;
  }

  function renderPowerTable(rows){
    if (!rows.length) return '<div class="small-muted">No hay potencia para calcular.</div>';

    const header = `
      <thead><tr>
        <th>A</th><th>B</th>
        <th>prop_A</th><th>prop_B</th>
        <th>Δ pp</th>
        <th>Potencia (aprox.)</th>
      </tr></thead>`;

    const body = rows.map(r=>{
      return `<tr>
        <td>${escapeHtml(r.A)}</td>
        <td>${escapeHtml(r.B)}</td>
        <td>${(r.prop_A*100).toFixed(1)}%</td>
        <td>${(r.prop_B*100).toFixed(1)}%</td>
        <td>${r.diff_pp.toFixed(1)}</td>
        <td><b>${r.power.toFixed(2)}</b></td>
      </tr>`;
    }).join('');

    return `<table class="table table-sm align-middle">${header}<tbody>${body}</tbody></table>`;
  }

  // =========================
  // UI Dinámica
  // =========================
  const headRow = document.getElementById('headRow');
  const rowFeed = document.getElementById('rowFeed');
  const rowNoFeed = document.getElementById('rowNoFeed');
  const btnAddCol = document.getElementById('btnAddCol');
  const btnRemoveCol = document.getElementById('btnRemoveCol');

  let chart = null;
  let lastSummaryRows = null;

  function colCount(){
    return headRow.querySelectorAll('th.colhdr').length;
  }

  function addColumn(name="Tratamiento"){
    const k = colCount() + 1;

    const th = document.createElement('th');
    th.className = 'colhdr';
    th.style.minWidth = '240px';
    th.innerHTML = `
      <div class="d-flex flex-column gap-1">
        <input class="form-control form-control-sm" data-role="colname" value="${escapeHtml(name)} ${k}" />
        <div class="small-muted">(conteos enteros ≥ 0)</div>
      </div>
    `;
    headRow.appendChild(th);

    const td1 = document.createElement('td');
    td1.innerHTML = `<input class="form-control form-control-sm" data-role="feed" type="number" min="0" step="1" value="0" />`;
    rowFeed.appendChild(td1);

    const td2 = document.createElement('td');
    td2.innerHTML = `<input class="form-control form-control-sm" data-role="nofeed" type="number" min="0" step="1" value="0" />`;
    rowNoFeed.appendChild(td2);
  }

  function removeLastColumn(){
    const k = colCount();
    if (k <= 2) return;
    headRow.removeChild(headRow.lastElementChild);
    rowFeed.removeChild(rowFeed.lastElementChild);
    rowNoFeed.removeChild(rowNoFeed.lastElementChild);
  }

  function clearAll(){
    while (colCount() > 4) removeLastColumn();
    while (colCount() < 4) addColumn('Tratamiento');

    [...headRow.querySelectorAll('input[data-role="colname"]')].forEach((el, idx)=> el.value = `Tratamiento ${idx+1}`);
    [...document.querySelectorAll('input[data-role="feed"], input[data-role="nofeed"]')].forEach(el => el.value = 0);

    document.getElementById('globalOut').innerHTML = '';
    document.getElementById('expectedWrap').innerHTML = '';
    document.getElementById('residWrap').innerHTML = '';
    document.getElementById('propOut').innerHTML = '';
    document.getElementById('pairsWrap').innerHTML = '';
    document.getElementById('pMatWrap').innerHTML = '';
    document.getElementById('powerWrap').innerHTML = '';
    lastSummaryRows = null;

    if (chart){ chart.destroy(); chart = null; }
  }

  function loadExample(){
    while (colCount() > 4) removeLastColumn();
    while (colCount() < 4) addColumn('');

    const names = [
      'Control KAT ES',
      'T1 Katal ES + premix ajo 10 kg/tm',
      'T2 Katal ES + Premix ajo china 10 kg/tm',
      'T3 Katal ES + 2 Kg/tm Citoprac'
    ];
    const feed = [14, 13, 35, 5];
    const nofeed = [66, 67, 45, 75];

    [...headRow.querySelectorAll('input[data-role="colname"]')].forEach((el, idx)=> el.value = names[idx] ?? `Tratamiento ${idx+1}`);
    [...rowFeed.querySelectorAll('input[data-role="feed"]')].forEach((el, idx)=> el.value = feed[idx] ?? 0);
    [...rowNoFeed.querySelectorAll('input[data-role="nofeed"]')].forEach((el, idx)=> el.value = nofeed[idx] ?? 0);
  }

  function readTable(){
    const names = [...headRow.querySelectorAll('input[data-role="colname"]')].map(x => (x.value || '').trim() || 'Sin nombre');
    const feed = [...rowFeed.querySelectorAll('input[data-role="feed"]')].map(x => safeInt(x.value));
    const nofeed = [...rowNoFeed.querySelectorAll('input[data-role="nofeed"]')].map(x => safeInt(x.value));

    if (names.length < 2) throw new Error('Necesitas al menos 2 tratamientos.');

    const obs = [feed, nofeed];
    const N = sum(feed) + sum(nofeed);
    if (N === 0) throw new Error('La tabla está vacía (N=0).');

    const colTotals = names.map((_,j)=> feed[j] + nofeed[j]);
    if (colTotals.some(t => t === 0)){
      throw new Error('Hay tratamientos con total 0. Llena al menos una celda por tratamiento.');
    }
    return {names, obs};
  }

  function renderExpected(names, E){
    let html = '<table class="table table-sm align-middle">';
    html += '<thead><tr><th>Fila</th>' + names.map(n=>`<th>${escapeHtml(n)}</th>`).join('') + '</tr></thead>';
    html += '<tbody>';
    html += '<tr><th>Alimentación</th>' + E[0].map(x=>`<td>${fmt(x,2)}</td>`).join('') + '</tr>';
    html += '<tr><th>No_alimentación</th>' + E[1].map(x=>`<td>${fmt(x,2)}</td>`).join('') + '</tr>';
    html += '</tbody></table>';
    return html;
  }

  function renderResiduals(names, Z, P, Pbonf, Pholm){
    const K = names.length;

    function rowHtml(label, i){
      let cells = '';
      for (let j=0;j<K;j++){
        cells += `
          <td>
            <div><span class="small-muted">z</span> ${fmt(Z[i][j],2)}</div>
            <div><span class="small-muted">p</span> ${fmt(P[i][j],3)}</div>
            <div><span class="small-muted">p_bonf</span> ${fmt(Pbonf[i][j],3)}</div>
            <div><span class="small-muted">p_holm</span> ${fmt(Pholm[i][j],3)}</div>
          </td>
        `;
      }
      return `<tr><th>${label}</th>${cells}</tr>`;
    }

    let html = '<table class="table table-sm align-middle">';
    html += '<thead><tr><th>Fila</th>' + names.map(n=>`<th>${escapeHtml(n)}</th>`).join('') + '</tr></thead>';
    html += '<tbody>';
    html += rowHtml('Alimentación', 0);
    html += rowHtml('No_alimentación', 1);
    html += '</tbody></table>';
    return html;
  }

  function renderGlobal({chi2, p, dof, V, pctBelow5, anyBelow1, fisher}){
    const warn1 = anyBelow1 ? pill('Esperado < 1: Sí', 'bad') : pill('Esperado < 1: No', 'ok');
    const warn5 = (pctBelow5 > 20) ? pill(`Esperados < 5: ${pctBelow5.toFixed(1)}%`, 'warn') : pill(`Esperados < 5: ${pctBelow5.toFixed(1)}%`, 'ok');

    const labelP = (pv) => {
      if (!Number.isFinite(pv)) return 'No disponible.';
      if (pv < 0.001) return 'Diferencias MUY claras (casi seguro no es azar).';
      if (pv < 0.05)  return 'Hay diferencias (p < 0.05).';
      return 'No se detectan diferencias claras entre tratamientos.';
    };

    const labelV = (v) => {
      if (!Number.isFinite(v)) return 'No disponible.';
      if (v < 0.10) return 'Impacto pequeño (cambio leve).';
      if (v < 0.30) return 'Impacto bajo a moderado.';
      if (v < 0.50) return 'Impacto moderado (relevante).';
      return 'Impacto grande (muy marcado).';
    };

    const labelExpected = () => {
      if (anyBelow1) return '⚠️ Hay celdas con esperado < 1: interpretar con cautela.';
      if (pctBelow5 > 20) return '⚠️ Muchos esperados < 5: interpretar con cautela.';
      return '✅ Los supuestos del test se cumplen bien.';
    };

    return `
      <div class="d-flex flex-wrap gap-2 mb-2">${warn1} ${warn5}</div>
      <div class="small-muted mb-3">${labelExpected()}</div>

      <div class="row g-2">
        <div class="col-md-6">
          <div class="small-muted">Chi-cuadrado</div>
          <div class="h5 mb-0">χ²(${dof}) = ${fmt(chi2,3)}</div>
          <div class="small-muted">Más grande = más distinta la alimentación entre tratamientos.</div>
        </div>

        <div class="col-md-6">
          <div class="small-muted">p-value (χ²)</div>
          <div class="h5 mb-0">p = ${fmtP(p)}</div>
          <div class="small-muted">${labelP(p)}</div>
        </div>

        <div class="col-md-6 mt-2">
          <div class="small-muted">V de Cramér</div>
          <div class="h6 mb-0">${fmt(V,3)} <span class="small-muted">(≈0.1 pequeño, 0.3 mediano, 0.5 grande)</span></div>
          <div class="small-muted">${labelV(V)}</div>
        </div>

        <div class="col-md-6 mt-2">
          <div class="small-muted">Fisher–Freeman–Halton (MC)</div>
          <div class="h6 mb-0">χ²≈${fmt(fisher.chiObs,3)}, p≈${fmtP(fisher.p)}</div>
          <div class="small-muted">Confirmación “más estricta”: si también sale significativo, la conclusión es sólida.</div>
        </div>
      </div>
    `;
  }

  function buildSummary(names, obs, Z, P, Pholm){
    const feed = obs[0];
    const totals = names.map((_,j)=> obs[0][j] + obs[1][j]);
    const props = names.map((_,j)=> feed[j] / totals[j]);

    const idx = props.map((v,i)=>({i,v})).sort((a,b)=>b.v-a.v).map(x=>x.i);

    return idx.map(j => ({
      tratamiento: names[j],
      prop_alim: props[j],
      z_alim: Z[0][j],
      p_alim: P[0][j],
      p_holm_alim: Pholm[0][j]
    }));
  }

  function renderProps(rows){
    const lines = rows.map(r => `
      <div class="d-flex justify-content-between gap-2">
        <div>${escapeHtml(r.tratamiento)}</div>
        <div><b>${(r.prop_alim*100).toFixed(1)}%</b></div>
      </div>
    `).join('');
    return `<div class="small-muted mb-2">Proporción de Alimentación por tratamiento (ordenado desc.)</div>${lines}`;
  }

  function drawChart(rows, fisherLine){
    const labels = rows.map(r => r.tratamiento);
    const data = rows.map(r => r.prop_alim);

    const ctx = document.getElementById('barChart');
    if (chart) chart.destroy();

    chart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [{
          label: 'Proporción de Alimentación',
          data,
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: true },
          title: {
            display: true,
            text: [
              'Proporción de Alimentación por Tratamiento',
              fisherLine
            ],
            color: '#e5e7eb'
          },
          tooltip: {
            callbacks: {
              label: (ctx) => ` ${(ctx.raw*100).toFixed(1)}%`
            }
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            max: 1,
            ticks: {
              callback: (v) => `${Math.round(v*100)}%`,
              color: '#cbd5e1'
            },
            grid: { color: '#1f2a3f' }
          },
          x: {
            ticks: { color: '#cbd5e1' },
            grid: { display: false }
          }
        }
      }
    });
  }

  function downloadCSV(rows){
    const header = ['tratamiento','prop_alim','z_alim','p_alim','p_holm_alim'];
    const csv = [header.join(',')].concat(
      rows.map(r => {
        const vals = [
          `"${String(r.tratamiento).replaceAll('"','""')}"`,
          r.prop_alim,
          r.z_alim,
          r.p_alim,
          r.p_holm_alim
        ];
        return vals.join(',');
      })
    ).join('\n');

    const blob = new Blob([csv], {type: 'text/csv;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'resumen_alimentacion.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // =========================
  // Ejecutar análisis
  // =========================
  async function run(){
    try {
      const {names, obs} = readTable();

      const alpha = Math.min(0.50, Math.max(0.001, Number(document.getElementById('alpha').value) || 0.05));

      const {chi2, p, dof, E, N, V} = chiSquare2xK(obs);

      const flatE = [...E[0], ...E[1]];
      const pctBelow5 = flatE.filter(x => x < 5).length / flatE.length * 100;
      const anyBelow1 = flatE.some(x => x < 1);

      const Z = stdResiduals(obs, E);
      const P = pvalsFromZ(Z);
      const Pbonf = bonferroni(P);
      const Pholm = holm(P);

      const nSim = Math.max(1000, safeInt(document.getElementById('nSim').value));
      const seed = safeInt(document.getElementById('seed').value);
      const fisher = fisherMC2xK(obs, nSim, seed);

      document.getElementById('globalOut').innerHTML = renderGlobal({chi2, p, dof, V, pctBelow5, anyBelow1, fisher});
      document.getElementById('expectedWrap').innerHTML = renderExpected(names, E);
      document.getElementById('residWrap').innerHTML = renderResiduals(names, Z, P, Pbonf, Pholm);

      const summaryRows = buildSummary(names, obs, Z, P, Pholm);
      lastSummaryRows = summaryRows;

      document.getElementById('propOut').innerHTML = renderProps(summaryRows);
      drawChart(summaryRows, `Fisher–Freeman–Halton (MC): χ²≈${fmt(fisher.chiObs,3)}, p≈${fmtP(fisher.p)}`);

      // NUEVO: pares + matriz + potencia
      const pairs = pairwiseComparisons(names, obs, alpha);
      document.getElementById('pairsWrap').innerHTML = renderPairsTable(pairs.rows, alpha);
      document.getElementById('pMatWrap').innerHTML  = renderPMatrix(names, pairs.pMat, alpha);
      document.getElementById('powerWrap').innerHTML = renderPowerTable(pairs.powerRows);

    } catch (err){
      alert(err?.message ?? String(err));
      console.error(err);
    }
  }

  // =========================
  // Eventos
  // =========================
  btnAddCol.addEventListener('click', () => addColumn('Tratamiento'));
  btnRemoveCol.addEventListener('click', removeLastColumn);
  document.getElementById('btnClear').addEventListener('click', clearAll);
  document.getElementById('btnExample').addEventListener('click', loadExample);
  document.getElementById('btnRun').addEventListener('click', run);
  document.getElementById('btnDownloadCSV').addEventListener('click', () => {
    if (!lastSummaryRows) return alert('Primero presiona Calcular.');
    downloadCSV(lastSummaryRows);
  });

  // init
  clearAll();
  loadExample();
</script>
</body>
</html>
