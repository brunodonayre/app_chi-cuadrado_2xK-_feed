<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>App 2×K: Alimentación vs No-alimentación</title>

  <!-- Bootstrap (solo UI) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- jStat: Normal/Chi-square CDF, etc. -->
  <script src="https://cdn.jsdelivr.net/npm/jstat@1.9.6/dist/jstat.min.js"></script>

  <!-- Chart.js para gráfico -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <style>
    body { background: #0b1220; }
    .card { border: 0; border-radius: 16px; }
    .card, .table { background: #0f172a; color: #e5e7eb; }
    .form-control, .form-select { background: #0b1220; color: #e5e7eb; border-color: #243146; }
    .form-control:focus, .form-select:focus { box-shadow: none; border-color: #3b82f6; }
    .btn-primary { border-radius: 12px; }
    .btn-outline-light, .btn-outline-danger { border-radius: 12px; }
    .table thead th { color: #cbd5e1; }
    .small-muted { color: #94a3b8; }
    .pill { display:inline-block; padding:.15rem .5rem; border-radius:999px; font-size:.8rem; }
    .pill-ok { background:#064e3b; color:#a7f3d0; }
    .pill-warn { background:#7c2d12; color:#fed7aa; }
    .pill-bad { background:#7f1d1d; color:#fecaca; }
    code { color:#93c5fd; }
  </style>
</head>

<body>
<div class="container py-4">
  <div class="row g-3">
    <div class="col-12">
      <div class="card p-4">
        <div class="d-flex flex-wrap gap-2 align-items-center justify-content-between">
          <div>
            <h1 class="h4 mb-1">App 2×K: Alimentación vs No-alimentación</h1>
            <div class="small-muted">Ingresa conteos por tratamiento. Calcula χ², V de Cramér, residuos z, correcciones (Bonferroni/Holm) y Fisher–Freeman–Halton (Monte Carlo).</div>
          </div>
          <div class="d-flex gap-2">
            <button class="btn btn-outline-light" id="btnExample">Cargar ejemplo</button>
            <button class="btn btn-outline-light" id="btnClear">Limpiar</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Entrada -->
    <div class="col-12">
      <div class="card p-4">
        <div class="d-flex flex-wrap gap-2 align-items-center justify-content-between mb-3">
          <h2 class="h6 mb-0">1) Tabla observada</h2>
          <div class="d-flex gap-2">
            <button class="btn btn-outline-light" id="btnAddCol">+ Tratamiento</button>
            <button class="btn btn-outline-danger" id="btnRemoveCol">- Último</button>
          </div>
        </div>

        <div class="table-responsive">
          <table class="table table-sm align-middle" id="obsTable">
            <thead>
              <tr id="headRow">
                <th style="min-width:200px">Fila</th>
                <!-- columnas dinámicas -->
              </tr>
            </thead>
            <tbody>
              <tr id="rowFeed">
                <th>Alimentación</th>
              </tr>
              <tr id="rowNoFeed">
                <th>No_alimentación</th>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="row g-3 mt-1">
          <div class="col-md-3">
            <label class="form-label">Simulaciones Fisher MC</label>
            <input class="form-control" id="nSim" type="number" min="1000" step="1000" value="100000" />
            <div class="small-muted">Más simulaciones = p más estable (pero más lento).</div>
          </div>
          <div class="col-md-3">
            <label class="form-label">Semilla</label>
            <input class="form-control" id="seed" type="number" step="1" value="123" />
            <div class="small-muted">Cambia la semilla si quieres otra corrida reproducible.</div>
          </div>
          <div class="col-md-3">
            <label class="form-label">Nivel de significancia (α)</label>
            <input class="form-control" id="alpha" type="number" min="0.001" max="0.50" step="0.01" value="0.05" />
            <div class="small-muted">Usual: 0.05 (5%), opcional: 0.10 o 0.15.</div>
          </div>
          <div class="col-md-3 d-flex align-items-end">
            <button class="btn btn-primary w-100" id="btnRun">Calcular</button>
          </div>
        </div>

        <div class="small-muted mt-3">
          Nota: los tests aquí replican tu script en Python para 2×K. Si hay esperados &lt; 1 o demasiados &lt; 5, interpreta con cautela.
        </div>
      </div>
    </div>

    <!-- Resultados -->
    <div class="col-12 col-lg-6">
      <div class="card p-4 h-100">
        <h2 class="h6">2) Resultados globales</h2>
        <div id="globalOut" class="mt-2"></div>
        <hr class="border-secondary" />
        <h2 class="h6">3) Esperados (E)</h2>
        <div class="table-responsive" id="expectedWrap"></div>
      </div>
    </div>

    <div class="col-12 col-lg-6">
      <div class="card p-4 h-100">
        <h2 class="h6">4) Proporción de Alimentación y gráfico</h2>
        <div id="propOut" class="mt-2"></div>
        <div class="mt-3">
          <canvas id="barChart" height="160"></canvas>
        </div>
        <div class="d-flex gap-2 mt-3">
          <button class="btn btn-outline-light" id="btnDownloadCSV">Descargar resumen CSV</button>
        </div>
      </div>
    </div>

    <div class="col-12">
      <div class="card p-4">
        <h2 class="h6">5) Residuos z y p-values por celda</h2>
        <div class="table-responsive" id="residWrap"></div>
        <div class="small-muted mt-2">Regla orientativa: |z| &gt; 1.96 ≈ p &lt; 0.05 (sin corrección).</div>
      </div>
    </div>

  </div>
</div>

<script>
  // =========================
  // Utilidades
  // =========================
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const fmt = (x, d=4) => (Number.isFinite(x) ? x.toFixed(d) : 'NA');
  const fmtP = (p) => (Number.isFinite(p) ? (p < 0.0001 ? '<0.0001' : p.toFixed(4)) : 'NA');
  const sum = (arr) => arr.reduce((a,b)=>a+b,0);

  function pill(text, kind){
    const cls = kind === 'ok' ? 'pill-ok' : kind === 'warn' ? 'pill-warn' : 'pill-bad';
    return `<span class="pill ${cls}">${text}</span>`;
  }

  function safeInt(v){
    const n = Number(v);
    if (!Number.isFinite(n) || n < 0) return 0;
    return Math.floor(n);
  }

  // =========================
  // RNG + Hypergeom (para Fisher MC)
  // =========================
  // xorshift32 simple (determinístico)
  function makeRng(seed){
    let x = (seed >>> 0) || 123456789;
    return function(){
      // xorshift32
      x ^= x << 13; x >>>= 0;
      x ^= x >> 17; x >>>= 0;
      x ^= x << 5;  x >>>= 0;
      return (x >>> 0) / 4294967296;
    }
  }

  // log factorial via Stirling + corrección para estabilidad
  function logFactorial(n){
    if (n < 2) return 0;
    // Stirling con corrección 1/(12n)
    return n*Math.log(n) - n + 0.5*Math.log(2*Math.PI*n) + 1/(12*n) - 1/(360*n*n*n);
  }

  function logChoose(n,k){
    if (k < 0 || k > n) return -Infinity;
    return logFactorial(n) - logFactorial(k) - logFactorial(n-k);
  }

  // PMF hipergeométrica: P(X=x) = [C(K,x) C(N-K, n-x)] / C(N,n)
  function hypergeomPmf(x, K, N, n){
    if (x < 0 || x > K || x > n || n-x > (N-K)) return 0;
    const logp = logChoose(K,x) + logChoose(N-K, n-x) - logChoose(N,n);
    return Math.exp(logp);
  }

  // Muestreo hipergeométrico por "inverse CDF" (OK para tamaños moderados)
  function hypergeomSample(rng, K, N, n){
    const xmin = Math.max(0, n - (N - K));
    const xmax = Math.min(n, K);
    let u = rng();
    let c = 0;
    for (let x = xmin; x <= xmax; x++){
      c += hypergeomPmf(x, K, N, n);
      if (u <= c) return x;
    }
    return xmax; // fallback por redondeos
  }

  // =========================
  // Cálculos 2×K
  // =========================
  function chiSquare2xK(obs2xK){
    const K = obs2xK[0].length;
    const rowTotals = [sum(obs2xK[0]), sum(obs2xK[1])];
    const colTotals = Array.from({length: K}, (_,j)=> obs2xK[0][j] + obs2xK[1][j]);
    const N = rowTotals[0] + rowTotals[1];

    // esperados
    const E = [[],[]];
    for (let j=0;j<K;j++){
      E[0][j] = rowTotals[0] * colTotals[j] / N;
      E[1][j] = rowTotals[1] * colTotals[j] / N;
    }

    // chi2
    let chi2 = 0;
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++){
        const e = E[i][j];
        if (e > 0) chi2 += (obs2xK[i][j]-e)*(obs2xK[i][j]-e)/e;
      }
    }

    const dof = (2-1)*(K-1);
    const p = 1 - jStat.chisquare.cdf(chi2, dof);

    // Cramér's V (2×K => denom=1)
    const denom = Math.min(2-1, K-1);
    const V = denom > 0 ? Math.sqrt(chi2 / (N * denom)) : NaN;

    return {chi2, p, dof, E, N};
  }

  function stdResiduals(obs, E){
    const K = obs[0].length;
    const Z = [[],[]];
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++){
        Z[i][j] = (obs[i][j] - E[i][j]) / Math.sqrt(E[i][j]);
      }
    }
    return Z;
  }

  function pvalsFromZ(Z){
    const K = Z[0].length;
    const P = [[],[]];
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++){
        const z = Math.abs(Z[i][j]);
        P[i][j] = 2*(1 - jStat.normal.cdf(z, 0, 1));
      }
    }
    return P;
  }

  function bonferroni(P){
    const K = P[0].length;
    const m = 2*K;
    const out = [[],[]];
    for (let i=0;i<2;i++){
      for (let j=0;j<K;j++) out[i][j] = clamp01(P[i][j]*m);
    }
    return out;
  }

  function holm(P){
    const K = P[0].length;
    const m = 2*K;
    const flat = [];
    for (let i=0;i<2;i++) for (let j=0;j<K;j++) flat.push({i,j,p:P[i][j]});
    flat.sort((a,b)=>a.p-b.p);

    // step-down: adj_k = max_{t<=k} (m - t + 1) * p_t
    let runningMax = 0;
    for (let k=0;k<m;k++){
      const t = k+1;
      const adj = (m - t + 1) * flat[k].p;
      runningMax = Math.max(runningMax, adj);
      flat[k].adj = clamp01(runningMax);
    }

    // reconstruir
    const out = [Array(K).fill(0), Array(K).fill(0)];
    for (const el of flat){ out[el.i][el.j] = el.adj; }
    return out;
  }

  // Fisher–Freeman–Halton MC (2×K): preserva márgenes
  function fisherMC2xK(obs2xK, nSim=100000, seed=123){
    const K = obs2xK[0].length;
    const colTotals = Array.from({length: K}, (_,j)=> obs2xK[0][j] + obs2xK[1][j]);
    const row1Tot = sum(obs2xK[0]);

    const {chi2: chiObs} = chiSquare2xK(obs2xK);

    const rng = makeRng(seed);
    let countGE = 0;

    for (let s=0; s<nSim; s++){
      let remainingSuccess = row1Tot;
      const remainingCol = colTotals.slice();
      const alloc = new Array(K).fill(0);

      for (let j=0; j<K-1; j++){
        const N = sum(remainingCol);
        const Kgood = remainingCol[j];
        const n = remainingSuccess;
        const x = hypergeomSample(rng, Kgood, N, n);
        alloc[j] = x;
        remainingSuccess -= x;
        remainingCol[j] = 0;
      }
      alloc[K-1] = remainingSuccess;

      const sim = [alloc, colTotals.map((ct,j)=>ct-alloc[j])];
      const {chi2: chiSim} = chiSquare2xK(sim);
      if (chiSim >= chiObs) countGE++;
    }

    return {chiObs, p: countGE / nSim};
  }

  // =========================
  // UI Dinámica
  // =========================
  const headRow = document.getElementById('headRow');
  const rowFeed = document.getElementById('rowFeed');
  const rowNoFeed = document.getElementById('rowNoFeed');
  const btnAddCol = document.getElementById('btnAddCol');
  const btnRemoveCol = document.getElementById('btnRemoveCol');

  let chart = null;
  let lastSummaryRows = null; // para CSV

  function colCount(){
    // 1 header fijo (Fila) + dinámicos
    return headRow.querySelectorAll('th.colhdr').length;
  }

  function addColumn(name="Tratamiento"){
    const k = colCount() + 1;

    // header
    const th = document.createElement('th');
    th.className = 'colhdr';
    th.style.minWidth = '240px';
    th.innerHTML = `
      <div class="d-flex flex-column gap-1">
        <input class="form-control form-control-sm" data-role="colname" value="${name} ${k}" />
        <div class="small-muted">(conteos enteros ≥ 0)</div>
      </div>
    `;
    headRow.appendChild(th);

    // celdas alimentación
    const td1 = document.createElement('td');
    td1.innerHTML = `<input class="form-control form-control-sm" data-role="feed" type="number" min="0" step="1" value="0" />`;
    rowFeed.appendChild(td1);

    // celdas no alimentación
    const td2 = document.createElement('td');
    td2.innerHTML = `<input class="form-control form-control-sm" data-role="nofeed" type="number" min="0" step="1" value="0" />`;
    rowNoFeed.appendChild(td2);
  }

  function removeLastColumn(){
    const k = colCount();
    if (k <= 2) return; // deja mínimo 2 tratamientos
    headRow.removeChild(headRow.lastElementChild);
    rowFeed.removeChild(rowFeed.lastElementChild);
    rowNoFeed.removeChild(rowNoFeed.lastElementChild);
  }

  function clearAll(){
    // deja 4 columnas por defecto
    while (colCount() > 4) removeLastColumn();
    while (colCount() < 4) addColumn('Tratamiento');

    // reset nombres
    [...headRow.querySelectorAll('input[data-role="colname"]')].forEach((el, idx)=> el.value = `Tratamiento ${idx+1}`);
    // reset valores
    [...document.querySelectorAll('input[data-role="feed"], input[data-role="nofeed"]')].forEach(el => el.value = 0);

    document.getElementById('globalOut').innerHTML = '';
    document.getElementById('expectedWrap').innerHTML = '';
    document.getElementById('residWrap').innerHTML = '';
    document.getElementById('propOut').innerHTML = '';
    lastSummaryRows = null;

    if (chart){ chart.destroy(); chart = null; }
  }

  function loadExample(){
    // 4 columnas (tu ejemplo)
    while (colCount() > 4) removeLastColumn();
    while (colCount() < 4) addColumn('');

    const names = [
      'Control KAT ES',
      'T1 Katal ES + premix ajo 10 kg/tm',
      'T2 Katal ES + Premix ajo china 10 kg/tm',
      'T3 Katal ES + 2 Kg/tm Citoprac'
    ];
    const feed = [14, 13, 35, 5];
    const nofeed = [66, 67, 45, 75];

    [...headRow.querySelectorAll('input[data-role="colname"]')].forEach((el, idx)=> el.value = names[idx] ?? `Tratamiento ${idx+1}`);
    [...rowFeed.querySelectorAll('input[data-role="feed"]')].forEach((el, idx)=> el.value = feed[idx] ?? 0);
    [...rowNoFeed.querySelectorAll('input[data-role="nofeed"]')].forEach((el, idx)=> el.value = nofeed[idx] ?? 0);
  }

  function readTable(){
    const names = [...headRow.querySelectorAll('input[data-role="colname"]')].map(x => (x.value || '').trim() || 'Sin nombre');
    const feed = [...rowFeed.querySelectorAll('input[data-role="feed"]')].map(x => safeInt(x.value));
    const nofeed = [...rowNoFeed.querySelectorAll('input[data-role="nofeed"]')].map(x => safeInt(x.value));

    // validar mínimo
    if (names.length < 2) throw new Error('Necesitas al menos 2 tratamientos.');

    const obs = [feed, nofeed];
    const N = sum(feed) + sum(nofeed);
    if (N === 0) throw new Error('La tabla está vacía (N=0).');

    // evita columnas con total 0 (rompe esperados)
    const colTotals = names.map((_,j)=> feed[j] + nofeed[j]);
    if (colTotals.some(t => t === 0)){
      throw new Error('Hay tratamientos con total 0. Llena al menos una celda por tratamiento.');
    }

    return {names, obs};
  }

  function renderExpected(names, E){
    const K = names.length;
    let html = '<table class="table table-sm align-middle">';
    html += '<thead><tr><th>Fila</th>' + names.map(n=>`<th>${escapeHtml(n)}</th>`).join('') + '</tr></thead>';
    html += '<tbody>';
    html += '<tr><th>Alimentación</th>' + E[0].map(x=>`<td>${fmt(x,2)}</td>`).join('') + '</tr>';
    html += '<tr><th>No_alimentación</th>' + E[1].map(x=>`<td>${fmt(x,2)}</td>`).join('') + '</tr>';
    html += '</tbody></table>';
    return html;
  }

  function renderResiduals(names, Z, P, Pbonf, Pholm){
    const K = names.length;

    function rowHtml(label, i){
      let cells = '';
      for (let j=0;j<K;j++){
        const z = Z[i][j];
        const p = P[i][j];
        const pb = Pbonf[i][j];
        const ph = Pholm[i][j];

        const sig = (p < 0.05) ? 'warn' : 'ok';
        cells += `
          <td>
            <div><span class="small-muted">z</span> ${fmt(z,2)}</div>
            <div><span class="small-muted">p</span> ${fmt(p,3)}</div>
            <div><span class="small-muted">p_bonf</span> ${fmt(pb,3)}</div>
            <div><span class="small-muted">p_holm</span> ${fmt(ph,3)}</div>
          </td>
        `;
      }
      return `<tr><th>${label}</th>${cells}</tr>`;
    }

    let html = '<table class="table table-sm align-middle">';
    html += '<thead><tr><th>Fila</th>' + names.map(n=>`<th>${escapeHtml(n)}</th>`).join('') + '</tr></thead>';
    html += '<tbody>';
    html += rowHtml('Alimentación', 0);
    html += rowHtml('No_alimentación', 1);
    html += '</tbody></table>';
    return html;
  }

  function escapeHtml(s){
    return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  function renderGlobal({chi2, p, dof, V, pctBelow5, anyBelow1, fisher}){
    const warn1 = anyBelow1 ? pill('Esperado < 1: Sí', 'bad') : pill('Esperado < 1: No', 'ok');
    const warn5 = (pctBelow5 > 20) ? pill(`Esperados < 5: ${pctBelow5.toFixed(1)}%`, 'warn') : pill(`Esperados < 5: ${pctBelow5.toFixed(1)}%`, 'ok');

    // Etiquetas amigables (interpretación simple)
    const labelP = (pv) => {
      if (!Number.isFinite(pv)) return 'No disponible.';
      if (pv < 0.001) return 'Diferencias MUY claras (casi seguro no es azar).';
      if (pv < 0.05)  return 'Hay diferencias (p < 0.05).';
      return 'No se detectan diferencias claras entre tratamientos.';
    };

    const labelV = (v) => {
      if (!Number.isFinite(v)) return 'No disponible.';
      if (v < 0.10) return 'Impacto pequeño (cambio leve).';
      if (v < 0.30) return 'Impacto bajo a moderado.';
      if (v < 0.50) return 'Impacto moderado (relevante).';
      return 'Impacto grande (muy marcado).';
    };

    const labelExpected = () => {
      if (anyBelow1) return '⚠️ Hay celdas con esperado < 1: interpretar con cautela.';
      if (pctBelow5 > 20) return '⚠️ Muchos esperados < 5: interpretar con cautela.';
      return '✅ Los supuestos del test se cumplen bien.';
    };

    const vTxt = Number.isFinite(V)
      ? `${fmt(V,3)} <span class="small-muted">(≈0.1 pequeño, 0.3 mediano, 0.5 grande)</span>`
      : 'NA';

    return `
      <div class="d-flex flex-wrap gap-2 mb-2">${warn1} ${warn5}</div>
      <div class="small-muted mb-3">${labelExpected()}</div>

      <div class="row g-2">
        <div class="col-md-6">
          <div class="small-muted">Chi-cuadrado</div>
          <div class="h5 mb-0">χ²(${dof}) = ${fmt(chi2,3)}</div>
          <div class="small-muted">Qué indica: mientras más grande, más distinta es la alimentación entre tratamientos.</div>
        </div>

        <div class="col-md-6">
          <div class="small-muted">p-value (χ²)</div>
          <div class="h5 mb-0">p = ${fmtP(p)}</div>
          <div class="small-muted">${labelP(p)}</div>
        </div>

        <div class="col-md-6 mt-2">
          <div class="small-muted">V de Cramér</div>
          <div class="h6 mb-0">${vTxt}</div>
          <div class="small-muted">${labelV(V)}</div>
        </div>

        <div class="col-md-6 mt-2">
          <div class="small-muted">Fisher–Freeman–Halton (MC)</div>
          <div class="h6 mb-0">χ²≈${fmt(fisher.chiObs,3)}, p≈${fmtP(fisher.p)}</div>
          <div class="small-muted">Confirmación “más estricta”: si también sale significativo, la conclusión es bien sólida.</div>
        </div>
      </div>
    `;
  }

  function buildSummary(names, obs, Z, P, Pholm){
    const feed = obs[0];
    const totals = names.map((_,j)=> obs[0][j] + obs[1][j]);
    const props = names.map((_,j)=> feed[j] / totals[j]);

    // orden desc por proporción
    const idx = props.map((v,i)=>({i,v})).sort((a,b)=>b.v-a.v).map(x=>x.i);

    const rows = idx.map(j => ({
      tratamiento: names[j],
      prop_alim: props[j],
      z_alim: Z[0][j],
      p_alim: P[0][j],
      p_holm_alim: Pholm[0][j]
    }));

    return rows;
  }

  function renderProps(rows){
    const lines = rows.map(r => `
      <div class="d-flex justify-content-between gap-2">
        <div>${escapeHtml(r.tratamiento)}</div>
        <div><b>${(r.prop_alim*100).toFixed(1)}%</b></div>
      </div>
    `).join('');
    return `<div class="small-muted mb-2">Proporción de Alimentación por tratamiento (ordenado desc.)</div>${lines}`;
  }

  function drawChart(rows, fisherLine){
    const labels = rows.map(r => r.tratamiento);
    const data = rows.map(r => r.prop_alim);

    const ctx = document.getElementById('barChart');
    if (chart) chart.destroy();

    chart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [{
          label: 'Proporción de Alimentación',
          data,
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: true },
          title: {
            display: true,
            text: [
              'Proporción de Alimentación por Tratamiento',
              fisherLine
            ],
            color: '#e5e7eb'
          },
          tooltip: {
            callbacks: {
              label: (ctx) => ` ${ (ctx.raw*100).toFixed(1) }%`
            }
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            max: 1,
            ticks: {
              callback: (v) => `${Math.round(v*100)}%`,
              color: '#cbd5e1'
            },
            grid: { color: '#1f2a3f' }
          },
          x: {
            ticks: { color: '#cbd5e1' },
            grid: { display: false }
          }
        }
      }
    });
  }

  function downloadCSV(rows){
    const header = ['tratamiento','prop_alim','z_alim','p_alim','p_holm_alim'];
    const csv = [header.join(',')].concat(
      rows.map(r => {
        const vals = [
          `"${String(r.tratamiento).replaceAll('"','""')}"`,
          r.prop_alim,
          r.z_alim,
          r.p_alim,
          r.p_holm_alim
        ];
        return vals.join(',');
      })
    ).join('\n');

    const blob = new Blob([csv], {type: 'text/csv;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'resumen_alimentacion.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // =========================
  // Ejecutar análisis
  // =========================
  async function run(){
    try {
      const {names, obs} = readTable();

      const {chi2, p, dof, E, N} = chiSquare2xK(obs);
      const V = Math.sqrt(chi2 / (N * Math.min(1, names.length-1))); // 2×K => denom=1

      // chequeo esperados
      const flatE = [...E[0], ...E[1]];
      const pctBelow5 = flatE.filter(x => x < 5).length / flatE.length * 100;
      const anyBelow1 = flatE.some(x => x < 1);

      // residuos y p
      const Z = stdResiduals(obs, E);
      const P = pvalsFromZ(Z);
      const Pbonf = bonferroni(P);
      const Pholm = holm(P);

      // Fisher MC
      const nSim = Math.max(1000, safeInt(document.getElementById('nSim').value));
      const seed = safeInt(document.getElementById('seed').value);
      const fisher = fisherMC2xK(obs, nSim, seed);

      // render
      document.getElementById('globalOut').innerHTML = renderGlobal({chi2, p, dof, V, pctBelow5, anyBelow1, fisher});
      document.getElementById('expectedWrap').innerHTML = renderExpected(names, E);
      document.getElementById('residWrap').innerHTML = renderResiduals(names, Z, P, Pbonf, Pholm);

      const summaryRows = buildSummary(names, obs, Z, P, Pholm);
      lastSummaryRows = summaryRows;

      document.getElementById('propOut').innerHTML = renderProps(summaryRows);
      drawChart(summaryRows, `Fisher–Freeman–Halton (MC): χ²≈${fmt(fisher.chiObs,3)}, p≈${fmtP(fisher.p)}`);

    } catch (err){
      alert(err?.message ?? String(err));
    }
  }

  // =========================
  // Eventos
  // =========================
  btnAddCol.addEventListener('click', () => addColumn('Tratamiento'));
  btnRemoveCol.addEventListener('click', removeLastColumn);
  document.getElementById('btnClear').addEventListener('click', clearAll);
  document.getElementById('btnExample').addEventListener('click', loadExample);
  document.getElementById('btnRun').addEventListener('click', run);
  document.getElementById('btnDownloadCSV').addEventListener('click', () => {
    if (!lastSummaryRows) return alert('Primero presiona Calcular.');
    downloadCSV(lastSummaryRows);
  });

  // init
  addColumn('Tratamiento');
  addColumn('Tratamiento');
  addColumn('Tratamiento');
  addColumn('Tratamiento');
  loadExample();
</script>
</body>
</html>
